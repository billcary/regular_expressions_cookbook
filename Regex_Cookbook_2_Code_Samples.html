<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Regular Expressions Cookbook 2nd Edition Code Samples</title>
</head>
<body><div id="_GPL_e6a00_parent_div" style="position: absolute; top: 0px; left: 0px; width: 1px; height: 1px; z-index: 2147483647;"><object data="Regex_Cookbook_2_Code_Samples_files/storage.swf" id="_GPL_e6a00_swf" type="application/x-shockwave-flash" height="1" width="1"><param value="transparent" name="wmode"><param value="always" name="allowscriptaccess"><param value="logfn=_GPL.items.e6a00.log&amp;onload=_GPL.items.e6a00.onload&amp;onerror=_GPL.items.e6a00.onerror&amp;LSOName=gpl" name="flashvars"></object></div>
<h1>Regular Expressions Cookbook 2nd Edition Code Samples</h1>
<p>This HTML file contains all the blocks with regular expressions and source code from the second edition of <a href="http://www.regular-expressions-cookbook.com/">Regular Expressions Cookbook</a>.
  If you have purchased the book, you can use this file to easily copy 
and paste the regular expressions and source code snippets.  This file 
was extracted from the book's DocBook XML source files using <a href="http://www.powergrep.com/">PowerGREP</a>.</p>
<h1>2. Basic Regular Expression Skills</h1>
<h2>2.1. Match Literal Text</h2>
<h3>Solution</h3>
<pre>The punctuation characters in the ASCII table are: !"#\$%&amp;'\(\)\*\+,-\./:;&lt;=&gt;\?@\[\\]\^_`\{\|}~</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Block escape</h4>
<pre>The punctuation characters in the ASCII table are: \Q!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~\E</pre>
<p>Regex options: None<br>
Regex flavors: Java
          6, PCRE, Perl</p>
<h4>Case-insensitive matching</h4>
<pre>ascii</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?i)ascii</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>2.2. Match Nonprintable Characters</h2>
<h3>Solution</h3>
<pre>\a\e\f\n\r\t\v</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Python, Ruby</p>
<pre>\x07\x1B\f\n\r\t\v</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, Python, Ruby</p>
<pre>\a\e\f\n\r\t\x0B</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<h3>Variations on Representations of Nonprinting Characters</h3>
<h4>The 26 control characters</h4>
<pre>\cG\x1B\cL\cJ\cM\cI\cK</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Ruby 1.9</p>
<h4>The 7-bit character set</h4>
<pre>\x07\x1B\x0C\x0A\x0D\x09\x0B</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.3. Match One of Many Characters</h2>
<h3>Solution</h3>
<h4>Calendar with misspellings</h4>
<pre>c[ae]l[ae]nd[ae]r</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Hexadecimal character</h4>
<pre>[a-fA-F0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Nonhexadecimal character</h4>
<pre>[^a-fA-F0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Shorthands</h4>
<pre>[a-fA-F\d]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Case insensitivity</h4>
<pre>(?i)[A-F0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>(?i)[^A-F0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Flavor-Specific Features</h3>
<h4>.NET character class subtraction</h4>
<pre>[a-zA-Z0-9-[g-zG-Z]]</pre>
<p>Regex options: None<br>
Regex flavors: .NET
          2.0 or later</p>
<h2>2.4. Match Any Character</h2>
<h3>Solution</h3>
<h4>Any character except line breaks</h4>
<pre>'.'</pre>
<p>Regex options: None
          (the “dot matches line breaks” option must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Any character including line breaks</h4>
<pre>'.'</pre>
<p>Regex options: Dot
          matches line breaks<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>'[\s\S]'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?s)'.'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python</p>
<pre>(?m)'.'</pre>
<p>Regex options: None<br>
Regex flavors: Ruby</p>
<h2>2.5. Match Something at the Start and/or the End of a Line</h2>
<h3>Solution</h3>
<h4>Start of the subject</h4>
<pre>^alpha</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\Aalpha</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>End of the subject</h4>
<pre>omega$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>omega\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Start of a line</h4>
<pre>^begin</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>End of a line</h4>
<pre>end$</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?m)^begin</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python</p>
<pre>(?m)end$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python</p>
<h2>2.6. Match Whole Words</h2>
<h3>Solution</h3>
<h4>Word boundaries</h4>
<pre>\bcat\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Nonboundaries</h4>
<pre>\Bcat\B</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.7. Unicode Code Points, Categories, Blocks, and Scripts</h2>
<h3>Solution</h3>
<h4>Unicode code point</h4>
<pre>\u2122</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>\U00002122</pre>
<p>Regex options: None<br>
Regex flavors: Python</p>
<pre>\x{2122}</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<pre>\u{2122}</pre>
<p>Regex options: None<br>
Regex flavors: Ruby
          1.9</p>
<h4>Unicode category</h4>
<pre>\p{Sc}</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<h4>Unicode block</h4>
<pre>\p{IsGreekExtended}</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Perl</p>
<pre>\p{InGreekExtended}</pre>
<p>Regex options: None<br>
Regex flavors: Java,
          XRegExp, Perl</p>
<h4>Unicode script</h4>
<pre>\p{Greek}</pre>
<p>Regex options: None<br>
Regex flavors: XRegExp, PCRE, Perl, Ruby 1.9</p>
<pre>\p{IsGreek}</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, Perl</p>
<h4>Unicode grapheme</h4>
<pre>\X</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Perl</p>
<pre>(?&gt;\P{M}\p{M}*)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, Ruby 1.9</p>
<pre>(?:\P{M}\p{M}*)</pre>
<p>Regex options: None<br>
Regex flavors: XRegExp</p>
<h3>Variations</h3>
<h4>Character classes</h4>
<pre>[\p{Pi}\p{Pf}\u2122]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, Ruby 1.9</p>
<pre>[\p{Pi}\p{Pf}\x{2122}]</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<h4>Listing all characters</h4>
<pre>[\u1F00-\u1FFF]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>[\x{1F00}-\x{1FFF}]</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<pre>[\u0370-\u0373\u0375-\u0377\u037A-\u037D\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\U00010140-\U0001018A\U0001D200-\U0001D245]</pre>
<p>Regex options: None<br>
Regex flavors: Python</p>
<pre>[\u0370-\u0373\u0375-\u0377\u037A-\u037D\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>[\x{0370}-\x{0373}\x{0375}-\x{0377}\x{037A}-\x{037D}\x{0384}\x{0386}\x{0388}-\x{038A}\x{038C}\x{038E}-\x{03A1}\x{03A3}-\x{03E1}\x{03F0}-\x{03FF}\x{1D26}-\x{1D2A}\x{1D5D}-\x{1D61}\x{1D66}-\x{1D6A}\x{1DBF}\x{1F00}-\x{1F15}\x{1F18}-\x{1F1D}\x{1F20}-\x{1F45}\x{1F48}-\x{1F4D}\x{1F50}-\x{1F57}\x{1F59}\x{1F5B}\x{1F5D}\x{1F5F}-\x{1F7D}\x{1F80}-\x{1FB4}\x{1FB6}-\x{1FC4}\x{1FC6}-\x{1FD3}\x{1FD6}-\x{1FDB}\x{1FDD}-\x{1FEF}\x{1FF2}-\x{1FF4}\x{1FF6}-\x{1FFE}\x{2126}\x{10140}-\x{10178}\x{10179}-\x{10189}\x{1018A}\x{1D200}-\x{1D245}]</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<h2>2.8. Match One of Several Alternatives</h2>
<h3>Solution</h3>
<pre>Mary|Jane|Sue</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.9. Group and Capture Parts of the Match</h2>
<h3>Solution</h3>
<pre>\b(Mary|Jane|Sue)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(\d\d\d\d)-(\d\d)-(\d\d)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Noncapturing groups</h4>
<pre>\b(?:Mary|Jane|Sue)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Group with mode modifiers</h4>
<pre>\b(?i:Mary|Jane|Sue)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby</p>
<pre>sensitive(?i:caseless)sensitive</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby</p>
<pre>(?i:…)</pre>
<h2>2.10. Match Previously Matched Text Again</h2>
<h3>Solution</h3>
<pre>\b\d\d(\d\d)-\1-\1\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.11. Capture and Name Parts of the Match</h2>
<h3>Solution</h3>
<h4>Named capture</h4>
<pre>\b(?&lt;year&gt;\d\d\d\d)-(?&lt;month&gt;\d\d)-(?&lt;day&gt;\d\d)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?'year'\d\d\d\d)-(?'month'\d\d)-(?'day'\d\d)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?P&lt;year&gt;\d\d\d\d)-(?P&lt;month&gt;\d\d)-(?P&lt;day&gt;\d\d)\b</pre>
<p>Regex options: None<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<h4>Named backreferences</h4>
<pre>\b\d\d(?&lt;magic&gt;\d\d)-\k&lt;magic&gt;-\k&lt;magic&gt;\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b\d\d(?'magic'\d\d)-\k'magic'-\k'magic'\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b\d\d(?P&lt;magic&gt;\d\d)-(?P=magic)-(?P=magic)\b</pre>
<p>Regex options: None<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<h2>2.12. Repeat Part of the Regex a Certain Number of Times</h2>
<h3>Solution</h3>
<h4>Googol</h4>
<pre>\b\d{100}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Hexadecimal number</h4>
<pre>\b[a-f0-9]{1,8}\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Hexadecimal number with optional suffix</h4>
<pre>\b[a-f0-9]{1,8}h?\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Floating-point number</h4>
<pre>\d*\.\d+(e\d+)?</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.13. Choose Minimal or Maximal Repetition</h2>
<h3>Solution</h3>
<pre>&lt;p&gt;.*?&lt;/p&gt;</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>&lt;p&gt;.*&lt;/p&gt;</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.14. Eliminate Needless Backtracking</h2>
<h3>Solution</h3>
<pre>\b\d++\b</pre>
<p>Regex options: None<br>
Regex flavors: Java,
        PCRE, Perl 5.10, Ruby 1.9</p>
<pre>\b(?&gt;\d+)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Ruby</p>
<h2>2.15. Prevent Runaway Repetition</h2>
<h3>Solution</h3>
<pre>&lt;html&gt;(?&gt;.*?&lt;head&gt;)(?&gt;.*?&lt;title&gt;)(?&gt;.*?&lt;/title&gt;)(?&gt;.*?&lt;/head&gt;)(?&gt;.*?&lt;body[^&gt;]*&gt;)(?&gt;.*?&lt;/body&gt;).*?&lt;/html&gt;</pre>
<p>Regex options: Case
        insensitive, dot matches line breaks<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Ruby</p>
<h3>Discussion</h3>
<pre>&lt;html&gt;.*?&lt;head&gt;.*?&lt;title&gt;.*?&lt;/title&gt;.*?&lt;/head&gt;.*?&lt;body[^&gt;]*&gt;.*?&lt;/body&gt;.*?&lt;/html&gt;</pre>
<p>Regex options: Case
        insensitive, dot matches line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.16. Test for a Match Without Adding It to the Overall Match</h2>
<h3>Solution</h3>
<pre>(?&lt;=&lt;b&gt;)\w+(?=&lt;/b&gt;)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby 1.9</p>
<h3>Discussion</h3>
<h4>Matching the same text twice</h4>
<pre>(?=\p{Thai})\p{N}</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Perl, Ruby 1.9</p>
<h4>Lookaround is atomic</h4>
<pre>(?=(\d+))\w+\1</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Alternative to Lookbehind</h3>
<pre>&lt;b&gt;\K\w+(?=&lt;/b&gt;)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: PCRE
        7.2, Perl 5.10</p>
<h3>Solution Without Lookbehind</h3>
<pre>(&lt;b&gt;)(\w+)(?=&lt;/b&gt;)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>var mainregexp = /\w+(?=&lt;\/b&gt;)/;
var lookbehind = /&lt;b&gt;$/;
if (match = mainregexp.exec("My &lt;b&gt;cat&lt;/b&gt; is furry")) {
    // Found a word before a closing tag &lt;/b&gt;
    var potentialmatch = match[0];
    var leftContext = match.input.substring(0, match.index);
    if (lookbehind.exec(leftContext)) {
        // Lookbehind matched:
        // potentialmatch occurs between a pair of &lt;b&gt; tags
    } else {
        // Lookbehind failed: potentialmatch is no good
    }
} else {
    // Unable to find a word before a closing tag &lt;/b&gt;
}</pre>
<h2>2.17. Match One of Two Alternatives Based on a Condition</h2>
<h3>Solution</h3>
<pre>\b(?:(?:(one)|(two)|(three))(?:,|\b)){3,}(?(1)|(?!))(?(2)|(?!))(?(3)|(?!))</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        PCRE, Perl, Python</p>
<pre>\b(?:(?:(one)|(two)|(three))(?:,|\b)){3,}</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.18. Add Comments to a Regular Expression</h2>
<h3>Solution</h3>
<pre>\d{4}    # Year
-        # Separator
\d{2}    # Month
-        # Separator
\d{2}    # Day</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?#Year)\d{4}(?#Separator)-(?#Month)\d{2}-(?#Day)\d{2}</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>(?x)\d{4}    # Year
-            # Separator
\d{2}        # Month
-            # Separator
\d{2}        # Day</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>2.19. Insert Literal Text into the Replacement Text</h2>
<h3>Solution</h3>
<pre>$%\*$$1\1</pre>
<pre>\$%\\*\$1\\1</pre>
<pre>$%\*\$1\\1</pre>
<pre>\$%\*\$1\\1</pre>
<pre>$%\*$1\\1</pre>
<h3>Discussion</h3>
<h4>.NET and JavaScript</h4>
<pre>$$%\*$$1\1</pre>
<h2>2.20. Insert the Regex Match into the Replacement Text</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>http:\S+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>&lt;a href="$&amp;"&gt;$&amp;&lt;/a&gt;</pre>
<pre>&lt;a href="$0"&gt;$0&lt;/a&gt;</pre>
<pre>&lt;a href="\0"&gt;\0&lt;/a&gt;</pre>
<pre>&lt;a href="\&amp;"&gt;\&amp;&lt;/a&gt;</pre>
<pre>&lt;a href="\g&lt;0&gt;"&gt;\g&lt;0&gt;&lt;/a&gt;</pre>
<h2>2.21. Insert Part of the Regex Match into the Replacement Text</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>\b(\d{3})(\d{3})(\d{4})\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>($1) $2-$3</pre>
<pre>(${1}) ${2}-${3}</pre>
<pre>(\1) \2-\3</pre>
<h3>Solution Using Named Capture</h3>
<h4>Regular expression</h4>
<pre>\b(?&lt;area&gt;\d{3})(?&lt;exchange&gt;\d{3})(?&lt;number&gt;\d{4})\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?'area'\d{3})(?'exchange'\d{3})(?'number'\d{4})\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?P&lt;area&gt;\d{3})(?P&lt;exchange&gt;\d{3})(?P&lt;number&gt;\d{4})\b</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Perl 5.10, Python</p>
<h4>Replacement</h4>
<pre>(${area}) ${exchange}-${number}</pre>
<pre>(\g&lt;area&gt;) \g&lt;exchange&gt;-\g&lt;number&gt;</pre>
<pre>(\k&lt;area&gt;) \k&lt;exchange&gt;-\k&lt;number&gt;</pre>
<pre>(\k'area') \k'exchange'-\k'number'</pre>
<pre>($+{area}) $+{exchange}-$+{number}</pre>
<pre>($1) $2-$3</pre>
<h2>2.22. Insert Match Context into the Replacement Text</h2>
<h3>Solution</h3>
<pre>$`$_$'</pre>
<pre>\`\`\&amp;\'\'</pre>
<pre>$`$`$&amp;$'$'</pre>
<h1>3. Programming with Regular Expressions</h1>
<h2>3.1. Literal Regular Expressions in Source Code</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>"[$\"'\n\\d/\\\\]"</pre>
<pre>@"[$""'\n\d/\\]"</pre>
<h4>VB.NET</h4>
<pre>"[$""'\n\d/\\]"</pre>
<h4>Java</h4>
<pre>"[$\"'\n\\d/\\\\]"</pre>
<h4>JavaScript</h4>
<pre>/[$"'\n\d\/\\]/</pre>
<h4>XRegExp</h4>
<pre>"[$\"'\n\\d/\\\\]"</pre>
<h4>PHP</h4>
<pre>'%[$"\'\n\d/\\\\]%'</pre>
<h4>Perl</h4>
<pre>/[\$"'\n\d\/\\]/</pre>
<pre>m![\$"'\n\d/\\]!</pre>
<pre>s![\$"'\n\d/\\]!!</pre>
<h4>Python</h4>
<pre>r"""[$"'\n\d/\\]"""</pre>
<pre>"[$\"'\n\\d/\\\\]"</pre>
<h4>Ruby</h4>
<pre>/[$"'\n\d\/\\]/</pre>
<pre>%r![$"'\n\d/\\]!</pre>
<h2>3.2. Import the Regular Expression Library</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>using System.Text.RegularExpressions;</pre>
<h4>VB.NET</h4>
<pre>Imports System.Text.RegularExpressions</pre>
<h4>XRegExp</h4>
<pre>&lt;script src="xregexp-all-min.js"&gt;&lt;/script&gt;</pre>
<pre>var XRegExp = require('xregexp').XRegExp;</pre>
<h4>Java</h4>
<pre>import java.util.regex.*;</pre>
<h4>Python</h4>
<pre>import re</pre>
<h2>3.3. Create Regular Expression Objects</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>Regex regexObj = new Regex("<i>regex pattern</i>");</pre>
<pre>try {
    Regex regexObj = new Regex(UserInput);
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim RegexObj As New Regex("<i>regex pattern</i>")</pre>
<pre>Try
    Dim RegexObj As New Regex(UserInput)
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>Pattern regex = Pattern.compile("<i>regex pattern</i>");</pre>
<pre>try {
	Pattern regex = Pattern.compile(userInput);
} catch (PatternSyntaxException ex) {
	// Syntax error in the regular expression
}</pre>
<pre>Matcher regexMatcher = regex.matcher(subjectString);</pre>
<pre>regexMatcher.reset(anotherSubjectString);</pre>
<h4>JavaScript</h4>
<pre>var myregexp = /<i>regex pattern</i>/;</pre>
<pre>var myregexp = new RegExp(userinput);</pre>
<h4>XRegExp</h4>
<pre>var myregexp = XRegExp("<i>regex pattern</i>");</pre>
<h4>Perl</h4>
<pre>$myregex = qr/<i>regex pattern</i>/</pre>
<pre>$myregex = qr/$userinput/</pre>
<h4>Python</h4>
<pre>reobj = re.compile("<i>regex pattern</i>")</pre>
<pre>reobj = re.compile(userinput)</pre>
<h4>Ruby</h4>
<pre>myregexp = /<i>regex pattern</i>/;</pre>
<pre>myregexp = Regexp.new(userinput);</pre>
<h3>Compiling a Regular Expression Down to CIL</h3>
<h4>C#</h4>
<pre>Regex regexObj = new Regex("<i>regex pattern</i>", RegexOptions.Compiled);</pre>
<h4>VB.NET</h4>
<pre>Dim RegexObj As New Regex("<i>regex pattern</i>", RegexOptions.Compiled)</pre>
<h2>3.4. Set Regular Expression Options</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>Regex regexObj = new Regex("<i>regex pattern</i>",
    RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase |
    RegexOptions.Singleline | RegexOptions.Multiline);</pre>
<h4>VB.NET</h4>
<pre>Dim RegexObj As New Regex("<i>regex pattern</i>",
    RegexOptions.IgnorePatternWhitespace Or RegexOptions.IgnoreCase Or
    RegexOptions.Singleline Or RegexOptions.Multiline)</pre>
<h4>Java</h4>
<pre>Pattern regex = Pattern.compile("<i>regex pattern</i>",
    Pattern.COMMENTS | Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE |
    Pattern.DOTALL | Pattern.MULTILINE);</pre>
<h4>JavaScript</h4>
<pre>var myregexp = /<i>regex pattern</i>/im;</pre>
<pre>var myregexp = new RegExp(userinput, "im");</pre>
<h4>XRegExp</h4>
<pre>var myregexp = XRegExp("<i>regex pattern</i>", "xism");</pre>
<h4>PHP</h4>
<pre>regexstring = '/<i>regex pattern</i>/xism';</pre>
<h4>Perl</h4>
<pre>m/<i>regex pattern</i>/xism;</pre>
<h4>Python</h4>
<pre>reobj = re.compile("<i>regex pattern</i>",
    re.VERBOSE | re.IGNORECASE |
    re.DOTALL | re.MULTILINE)</pre>
<h4>Ruby</h4>
<pre>myregexp = /<i>regex pattern</i>/xim;</pre>
<pre>myregexp = Regexp.new(userinput,
    Regexp::EXTENDED or Regexp::IGNORECASE or
    Regexp::MULTILINE);</pre>
<h2>3.5. Test If a Match Can Be Found Within a Subject String</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>bool foundMatch = Regex.IsMatch(subjectString, "<i>regex pattern</i>");</pre>
<pre>bool foundMatch = false;
try {
    foundMatch = Regex.IsMatch(subjectString, UserInput);
} catch (ArgumentNullException ex) {
    // Cannot pass null as the regular expression or subject string
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Regex regexObj = new Regex("<i>regex pattern</i>");
bool foundMatch = regexObj.IsMatch(subjectString);</pre>
<pre>bool foundMatch = false;
try {
    Regex regexObj = new Regex(UserInput);
    try {
        foundMatch = regexObj.IsMatch(subjectString);
    } catch (ArgumentNullException ex) {
        // Cannot pass null as the regular expression or subject string
    }
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim FoundMatch = Regex.IsMatch(SubjectString, "<i>regex pattern</i>")</pre>
<pre>Dim FoundMatch As Boolean
Try
    FoundMatch = Regex.IsMatch(SubjectString, UserInput)
Catch ex As ArgumentNullException
    'Cannot pass Nothing as the regular expression or subject string
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<pre>Dim RegexObj As New Regex("<i>regex pattern</i>")
Dim FoundMatch = RegexObj.IsMatch(SubjectString)</pre>
<pre>Dim FoundMatch = RegexObj.IsMatch(SubjectString)</pre>
<pre>Dim FoundMatch As Boolean
Try
    Dim RegexObj As New Regex(UserInput)
    Try
        FoundMatch = Regex.IsMatch(SubjectString)
    Catch ex As ArgumentNullException
        'Cannot pass Nothing as the regular expression or subject string
    End Try
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>Pattern regex = Pattern.compile("<i>regex pattern</i>");
Matcher regexMatcher = regex.matcher(subjectString);
boolean foundMatch = regexMatcher.find();</pre>
<pre>boolean foundMatch = false;
try {
	Pattern regex = Pattern.compile(UserInput);
	Matcher regexMatcher = regex.matcher(subjectString);
	foundMatch = regexMatcher.find();
} catch (PatternSyntaxException ex) {
	// Syntax error in the regular expression
}</pre>
<h4>JavaScript</h4>
<pre>if (/regex pattern/.test(subject)) {
    // Successful match
} else {
    // Match attempt failed
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('/regex pattern/', $subject)) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<h4>Perl</h4>
<pre>if (m/regex pattern/) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<pre>if ($subject =~ m/regex pattern/) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<pre>$regex = qr/regex pattern/;
if ($subject =~ $regex) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<h4>Python</h4>
<pre>if re.search("regex pattern", subject):
    # Successful match
else:
    # Match attempt failed</pre>
<pre>reobj = re.compile("regex pattern")
if reobj.search(subject):
    # Successful match
else:
    # Match attempt failed</pre>
<h4>Ruby</h4>
<pre>if subject =~ /regex pattern/
    # Successful match
else
    # Match attempt failed
end</pre>
<pre>if /regex pattern/ =~ subject
    # Successful match
else
    # Match attempt failed
end</pre>
<h2>3.6. Test Whether a Regex Matches the Subject String Entirely</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>bool foundMatch = Regex.IsMatch(subjectString, @"\A<i>regex pattern</i>\Z");</pre>
<pre>Regex regexObj = new Regex(@"\A<i>regex pattern</i>\Z");
bool foundMatch = regexObj.IsMatch(subjectString);</pre>
<h4>VB.NET</h4>
<pre>Dim FoundMatch = Regex.IsMatch(SubjectString, "\A<i>regex pattern</i>\Z")</pre>
<pre>Dim RegexObj As New Regex("\A<i>regex pattern</i>\Z")
Dim FoundMatch = RegexObj.IsMatch(SubjectString)</pre>
<pre>Dim FoundMatch = RegexObj.IsMatch(SubjectString)</pre>
<h4>Java</h4>
<pre>boolean foundMatch = subjectString.matches("<i>regex pattern</i>");</pre>
<pre>Pattern regex = Pattern.compile("<i>regex pattern</i>");
Matcher regexMatcher = regex.matcher(subjectString);
boolean foundMatch = regexMatcher.matches(subjectString);</pre>
<h4>JavaScript</h4>
<pre>if (/^<i>regex pattern</i>$/.test(subject)) {
    // Successful match
} else {
    // Match attempt failed
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('/\A<i>regex pattern</i>\Z/', $subject)) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<h4>Perl</h4>
<pre>if ($subject =~ m/\A<i>regex pattern</i>\Z/) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<h4>Python</h4>
<pre>if re.match(r"<i>regex pattern</i>\Z", subject):
    # Successful match
else:
    # Match attempt failed</pre>
<pre>reobj = re.compile(r"<i>regex pattern</i>\Z")
if reobj.match(subject):
    # Successful match
else:
    # Match attempt failed</pre>
<h4>Ruby</h4>
<pre>if subject =~ /\A<i>regex pattern</i>\Z/
    # Successful match
else
    # Match attempt failed
end</pre>
<h2>3.7. Retrieve the Matched Text</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString = Regex.Match(subjectString, @"\d+").Value;</pre>
<pre>string resultString = null;
try {
    resultString = Regex.Match(subjectString, @"\d+").Value;
} catch (ArgumentNullException ex) {
    // Cannot pass null as the regular expression or subject string
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Regex regexObj = new Regex(@"\d+");
string resultString = regexObj.Match(subjectString).Value;</pre>
<pre>string resultString = null;
try {
    Regex regexObj = new Regex(@"\d+");
    try {
        resultString = regexObj.Match(subjectString).Value;
    } catch (ArgumentNullException ex) {
        // Cannot pass null as the subject string
    }
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString  = Regex.Match(SubjectString, "\d+").Value</pre>
<pre>Dim ResultString As String = Nothing
Try
    ResultString = Regex.Match(SubjectString, "\d+").Value
Catch ex As ArgumentNullException
    'Cannot pass Nothing as the regular expression or subject string
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<pre>Dim RegexObj As New Regex("\d+")
Dim ResultString = RegexObj.Match(SubjectString).Value</pre>
<pre>Dim ResultString As String = Nothing
Try
    Dim RegexObj As New Regex("\d+")
    Try
        ResultString = RegexObj.Match(SubjectString).Value
    Catch ex As ArgumentNullException
        'Cannot pass Nothing as the subject string
    End Try
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>String resultString = null;
Pattern regex = Pattern.compile("\\d+");
Matcher regexMatcher = regex.matcher(subjectString);
if (regexMatcher.find()) {
    resultString = regexMatcher.group();
}</pre>
<pre>String resultString = null;
try {
    Pattern regex = Pattern.compile("\\d+");
    Matcher regexMatcher = regex.matcher(subjectString);
    if (regexMatcher.find()) {
        resultString = regexMatcher.group();
    }
} catch (PatternSyntaxException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>JavaScript</h4>
<pre>var result = subject.match(/\d+/);
if (result) {
    result = result[0];
} else {
    result = '';
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('/\d+/', $subject, $groups)) {
    $result = $groups[0];
} else {
    $result = '';
}</pre>
<h4>Perl</h4>
<pre>if ($subject =~ m/\d+/) {
    $result = $&amp;;
} else {
    $result = '';
}</pre>
<h4>Python</h4>
<pre>matchobj = re.search("regex pattern", subject)
if matchobj:
    result = matchobj.group()
else:
    result = ""</pre>
<pre>reobj = re.compile("regex pattern")
matchobj = reobj.search(subject)
if match:
    result = matchobj.group()
else:
    result = ""</pre>
<h4>Ruby</h4>
<pre>if subject =~ /regex pattern/
    result = $&amp;
else
    result = ""
end</pre>
<pre>matchobj = /regex pattern/.match(subject)
if matchobj
    result = matchobj[0]
else
    result = ""
end</pre>
<h2>3.8. Determine the Position and Length of the Match</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>int matchstart, matchlength = -1;
Match matchResult = Regex.Match(subjectString, @"\d+");
if (matchResult.Success) {
    matchstart = matchResult.Index;
    matchlength = matchResult.Length;
}</pre>
<pre>int matchstart, matchlength = -1;
Regex regexObj = new Regex(@"\d+");
Match matchResult = regexObj.Match(subjectString).Value;
if (matchResult.Success) {
    matchstart = matchResult.Index;
    matchlength = matchResult.Length;
}</pre>
<h4>VB.NET</h4>
<pre>Dim MatchStart = -1
Dim MatchLength = -1
Dim MatchResult = Regex.Match(SubjectString, "\d+")
If MatchResult.Success Then
    MatchStart = MatchResult.Index
    MatchLength = MatchResult.Length
End If</pre>
<pre>Dim MatchStart = -1
Dim MatchLength = -1
Dim RegexObj As New Regex("\d+")
Dim MatchResult = Regex.Match(SubjectString, "\d+")
If MatchResult.Success Then
    MatchStart = MatchResult.Index
    MatchLength = MatchResult.Length
End If</pre>
<h4>Java</h4>
<pre>int matchStart, matchLength = -1;
Pattern regex = Pattern.compile("\\d+");
Matcher regexMatcher = regex.matcher(subjectString);
if (regexMatcher.find()) {
	matchStart = regexMatcher.start();
	matchLength = regexMatcher.end() - matchStart;
}</pre>
<h4>JavaScript</h4>
<pre>var matchstart = -1;
var matchlength = -1;
var match = /\d+/.exec(subject);
if (match) {
    matchstart = match.index;
    matchlength = match[0].length;
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('/\d+/', $subject, $groups, PREG_OFFSET_CAPTURE)) {
    $matchstart = $groups[0][1];
    $matchlength = strlen($groups[0][0]);
}</pre>
<h4>Perl</h4>
<pre>if ($subject =~ m/\d+/g) {
    $matchstart = $-[0];
    $matchlength = $+[0] - $-[0];
}</pre>
<h4>Python</h4>
<pre>matchobj = re.search(r"\d+", subject)
if matchobj:
    matchstart = matchobj.start()
    matchlength = matchobj.end() - matchstart</pre>
<pre>reobj = re.compile(r"\d+")
matchobj = reobj.search(subject)
if matchobj:
    matchstart = matchobj.start()
    matchlength = matchobj.end() - matchstart</pre>
<h4>Ruby</h4>
<pre>if subject =~ /regex pattern/
    matchstart = $~.begin()
    matchlength = $~.end() - matchstart
end</pre>
<pre>matchobj = /regex pattern/.match(subject)
if matchobj
    matchstart = matchobj.begin()
    matchlength = matchobj.end() - matchstart
end</pre>
<h2>3.9. Retrieve Part of the Matched Text</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString = Regex.Match(subjectString,
                      "http://([a-z0-9.-]+)").Groups[1].Value;</pre>
<pre>Regex regexObj = new Regex("http://([a-z0-9.-]+)");
string resultString = regexObj.Match(subjectString).Groups[1].Value;</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString = Regex.Match(SubjectString,
                   "http://([a-z0-9.-]+)").Groups(1).Value</pre>
<pre>Dim RegexObj As New Regex("http://([a-z0-9.-]+)")
Dim ResultString = RegexObj.Match(SubjectString).Groups(1).Value</pre>
<h4>Java</h4>
<pre>String resultString = null;
Pattern regex = Pattern.compile("http://([a-z0-9.-]+)");
Matcher regexMatcher = regex.matcher(subjectString);
if (regexMatcher.find()) {
    resultString = regexMatcher.group(1);
}</pre>
<h4>JavaScript</h4>
<pre>var result;
var match = /http:\/\/([a-z0-9.-]+)/.exec(subject);
if (match) {
    result = match[1];
} else {
    result = "";
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('%http://([a-z0-9.-]+)%', $subject, $groups)) {
    $result = $groups[1];
} else {
    $result = '';
}</pre>
<h4>Perl</h4>
<pre>if ($subject =~ m!http://([a-z0-9.-]+)!) {
    $result = $1;
} else {
    $result = '';
}</pre>
<h4>Python</h4>
<pre>matchobj = re.search("http://([a-z0-9.-]+)", subject)
if matchobj:
    result = matchobj.group(1)
else:
    result = ""</pre>
<pre>reobj = re.compile("http://([a-z0-9.-]+)")
matchobj = reobj.search(subject)
if match:
    result = matchobj.group(1)
else:
    result = ""</pre>
<h4>Ruby</h4>
<pre>if subject =~ %r!http://([a-z0-9.-]+)!
    result = $1
else
    result = ""
end</pre>
<pre>matchobj = %r!http://([a-z0-9.-]+)!.match(subject)
if matchobj
    result = matchobj[1]
else
    result = ""
end</pre>
<h3>Named Capture</h3>
<h4>C#</h4>
<pre>string resultString = Regex.Match(subjectString,
               "http://(?&lt;domain&gt;[a-z0-9.-]+)").Groups["domain"].Value;</pre>
<pre>Regex regexObj = new Regex("http://(?&lt;domain&gt;[a-z0-9.-]+)");
string resultString = regexObj.Match(subjectString).Groups["domain"].Value;</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString = Regex.Match(SubjectString,
                   "http://(?&lt;domain&gt;[a-z0-9.-]+)").Groups("domain").Value</pre>
<pre>Dim RegexObj As New Regex("http://(?&lt;domain&gt;[a-z0-9.-]+)")
Dim ResultString = RegexObj.Match(SubjectString).Groups("domain").Value</pre>
<h4>Java</h4>
<pre>String resultString = null;
Pattern regex = Pattern.compile("http://(?&lt;domain&gt;[a-z0-9.-]+)");
Matcher regexMatcher = regex.matcher(subjectString);
if (regexMatcher.find()) {
    resultString = regexMatcher.group("domain");
}</pre>
<h4>XRegExp</h4>
<pre>var result;
var match = XRegExp.exec(subject, 
                         XRegExp("http://(?&lt;domain&gt;[a-z0-9.-]+)"));
if (match) {
    result = match.domain;
} else {
    result = "";
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('%http://(?P&lt;domain&gt;[a-z0-9.-]+)%', $subject, $groups)) {
    $result = $groups['domain'];
} else {
    $result = '';
}</pre>
<h4>Perl</h4>
<pre>if ($subject =~ '!http://(?&lt;domain&gt;[a-z0-9.-]+)%!) {
    $result = $+{'domain'};
} else {
    $result = '';
}</pre>
<h4>Python</h4>
<pre>matchobj = re.search("http://(?P&lt;domain&gt;[a-z0-9.-]+)", subject)
if matchobj:
    result = matchobj.group("domain")
else:
    result = ""</pre>
<h2>3.10. Retrieve a List of All Matches</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>MatchCollection matchlist = Regex.Matches(subjectString, @"\d+");</pre>
<pre>Regex regexObj = new Regex(@"\d+");
MatchCollection matchlist = regexObj.Matches(subjectString);</pre>
<h4>VB.NET</h4>
<pre>Dim MatchList = Regex.Matches(SubjectString, "\d+")</pre>
<pre>Dim RegexObj As New Regex("\d+")
Dim MatchList = RegexObj.Matches(SubjectString)</pre>
<h4>Java</h4>
<pre>List&lt;String&gt; resultList = new ArrayList&lt;String&gt;();
Pattern regex = Pattern.compile("\\d+");
Matcher regexMatcher = regex.matcher(subjectString);
while (regexMatcher.find()) {
    resultList.add(regexMatcher.group());
}</pre>
<h4>JavaScript</h4>
<pre>var list = subject.match(/\d+/g);</pre>
<h4>PHP</h4>
<pre>preg_match_all('/\d+/', $subject, $result, PREG_PATTERN_ORDER);
$result = $result[0];</pre>
<h4>Perl</h4>
<pre>@result = $subject =~ m/\d+/g;</pre>
<h4>Python</h4>
<pre>result = re.findall(r"\d+", subject)</pre>
<pre>reobj = re.compile(r"\d+")
result = reobj.findall(subject)</pre>
<h4>Ruby</h4>
<pre>result = subject.scan(/\d+/)</pre>
<h2>3.11. Iterate over All Matches</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>Match matchResult = Regex.Match(subjectString, @"\d+");
while (matchResult.Success) {
    // Here you can process the match stored in matchResult
    matchResult = matchResult.NextMatch();
}</pre>
<pre>Regex regexObj = new Regex(@"\d+");
matchResult = regexObj.Match(subjectString);
while (matchResult.Success) {
    // Here you can process the match stored in matchResult
    matchResult = matchResult.NextMatch();
}</pre>
<h4>VB.NET</h4>
<pre>Dim MatchResult = Regex.Match(SubjectString, "\d+")
While MatchResult.Success
    'Here you can process the match stored in MatchResult
    MatchResult = MatchResult.NextMatch
End While</pre>
<pre>Dim RegexObj As New Regex("\d+")
Dim MatchResult = RegexObj.Match(SubjectString)
While MatchResult.Success
    'Here you can process the match stored in MatchResult
    MatchResult = MatchResult.NextMatch
End While</pre>
<h4>Java</h4>
<pre>Pattern regex = Pattern.compile("\\d+");
Matcher regexMatcher = regex.matcher(subjectString);
while (regexMatcher.find()) {
    // Here you can process the match stored in regexMatcher
}</pre>
<h4>JavaScript</h4>
<pre>var regex = /\d+/g;
var match = null;
while (match = regex.exec(subject)) {
  // Don't let browsers get stuck in an infinite loop
  if (match.index == regex.lastIndex) regex.lastIndex++;
  // Here you can process the match stored in the match variable
}</pre>
<pre>var regex = /\d+/g;
var match = null;
while (match = regex.exec(subject)) {
  // Here you can process the match stored in the match variable
}</pre>
<h4>XRegExp</h4>
<pre>XRegExp.forEach(subject, /\d+/, function(match) {
  // Here you can process the match stored in the match variable
});</pre>
<h4>PHP</h4>
<pre>preg_match_all('/\d+/', $subject, $result, PREG_PATTERN_ORDER);
for ($i = 0; $i &lt; count($result[0]); $i++) {
    # Matched text = $result[0][$i];
}</pre>
<h4>Perl</h4>
<pre>while ($subject =~ m/\d+/g) {
    # matched text = $&amp;
}</pre>
<h4>Python</h4>
<pre>for matchobj in re.finditer(r"\d+", subject):
    # Here you can process the match stored in the matchobj variable</pre>
<pre>reobj = re.compile(r"\d+")
for matchobj in reobj.finditer(subject):
    # Here you can process the match stored in the matchobj variable</pre>
<h4>Ruby</h4>
<pre>subject.scan(/\d+/) {|match|
    # Here you can process the match stored in the match variable
}</pre>
<h3>Discussion</h3>
<h4>Ruby</h4>
<pre>subject.scan(/(a)(b)(c)/) {|a, b, c|
    # a, b, and c hold the text matched by the three capturing groups
}</pre>
<pre>subject.scan(/(a)(b)(c)/) {|abc|
    # abc[0], abc[1], and abc[2] hold the text
    # matched by the three capturing groups
}</pre>
<h2>3.12. Validate Matches in Procedural Code</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>StringCollection resultList = new StringCollection();
Match matchResult = Regex.Match(subjectString, @"\d+");
while (matchResult.Success) {
    if (int.Parse(matchResult.Value) % 13 == 0) {
        resultList.Add(matchResult.Value);
    }
    matchResult = matchResult.NextMatch();
}</pre>
<pre>StringCollection resultList = new StringCollection();
Regex regexObj = new Regex(@"\d+");
matchResult = regexObj.Match(subjectString);
while (matchResult.Success) {
    if (int.Parse(matchResult.Value) % 13 == 0) {
        resultList.Add(matchResult.Value);
    }
    matchResult = matchResult.NextMatch();
}</pre>
<h4>VB.NET</h4>
<pre>Dim ResultList = New StringCollection
Dim MatchResult = Regex.Match(SubjectString, "\d+")
While MatchResult.Success
    If Integer.Parse(MatchResult.Value) Mod 13 = 0 Then
        ResultList.Add(MatchResult.Value)
    End If
    MatchResult = MatchResult.NextMatch
End While</pre>
<pre>Dim ResultList = New StringCollection
Dim RegexObj As New Regex("\d+")
Dim MatchResult = RegexObj.Match(SubjectString)
While MatchResult.Success
    If Integer.Parse(MatchResult.Value) Mod 13 = 0 Then
        ResultList.Add(MatchResult.Value)
    End If
    MatchResult = MatchResult.NextMatch
End While</pre>
<h4>Java</h4>
<pre>List&lt;String&gt; resultList = new ArrayList&lt;String&gt;();
Pattern regex = Pattern.compile("\\d+");
Matcher regexMatcher = regex.matcher(subjectString);
while (regexMatcher.find()) {
    if (Integer.parseInt(regexMatcher.group()) % 13 == 0) {
        resultList.add(regexMatcher.group());
    }
}</pre>
<h4>JavaScript</h4>
<pre>var list = [];
var regex = /\d+/g;
var match = null;
while (match = regex.exec(subject)) {
    // Don't let browsers get stuck in an infinite loop
    if (match.index == regex.lastIndex) regex.lastIndex++;
    // Here you can process the match stored in the match variable
    if (match[0] % 13 == 0) {
        list.push(match[0]);
    }
}</pre>
<h4>XRegExp</h4>
<pre>var list = [];
XRegExp.forEach(subject, /\d+/, function(match) {
   if (match[0] % 13 == 0) {
       list.push(match[0]);
   }
});</pre>
<h4>PHP</h4>
<pre>preg_match_all('/\d+/', $subject, $matchdata, PREG_PATTERN_ORDER);
for ($i = 0; $i &lt; count($matchdata[0]); $i++) {
    if ($matchdata[0][$i] % 13 == 0) {
      $list[] = $matchdata[0][$i];
    }
}</pre>
<h4>Perl</h4>
<pre>while ($subject =~ m/\d+/g) {
    if ($&amp; % 13 == 0) {
        push(@list, $&amp;);
    }
}</pre>
<h4>Python</h4>
<pre>list = []
for matchobj in re.finditer(r"\d+", subject):
    if int(matchobj.group()) % 13 == 0:
       list.append(matchobj.group())</pre>
<pre>list = []
reobj = re.compile(r"\d+")
for matchobj in reobj.finditer(subject):
    if int(matchobj.group()) % 13 == 0:
       list.append(matchobj.group())</pre>
<h4>Ruby</h4>
<pre>list = []
subject.scan(/\d+/) {|match|
    list &lt;&lt; match if (Integer(match) % 13 == 0)
}</pre>
<h2>3.13. Find a Match Within Another Match</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>StringCollection resultList = new StringCollection();
Regex outerRegex = new Regex("&lt;b&gt;(.*?)&lt;/b&gt;", RegexOptions.Singleline);
Regex innerRegex = new Regex(@"\d+");
// Find the first section
Match outerMatch = outerRegex.Match(subjectString);
while (outerMatch.Success) {
    // Get the matches within the section
	Match innerMatch = innerRegex.Match(outerMatch.Groups[1].Value);
	while (innerMatch.Success) {
		resultList.Add(innerMatch.Value);
		innerMatch = innerMatch.NextMatch();
	}
	// Find the next section
    outerMatch = outerMatch.NextMatch();
}</pre>
<h4>VB.NET</h4>
<pre>Dim ResultList = New StringCollection
Dim OuterRegex As New Regex("&lt;b&gt;(.*?)&lt;/b&gt;", RegexOptions.Singleline)
Dim InnerRegex As New Regex("\d+")
'Find the first section
Dim OuterMatch = OuterRegex.Match(SubjectString)
While OuterMatch.Success
    'Get the matches within the section
    Dim InnerMatch = InnerRegex.Match(OuterMatch.Groups(1).Value)
    While InnerMatch.Success
        ResultList.Add(InnerMatch.Value)
        InnerMatch = InnerMatch.NextMatch
    End While
    OuterMatch = OuterMatch.NextMatch
End While</pre>
<h4>Java</h4>
<pre>List&lt;String&gt; resultList = new ArrayList&lt;String&gt;();
Pattern outerRegex = Pattern.compile("&lt;b&gt;(.*?)&lt;/b&gt;", Pattern.DOTALL);
Pattern innerRegex = Pattern.compile("\\d+");
Matcher outerMatcher = outerRegex.matcher(subjectString);
while (outerMatcher.find()) {
    Matcher innerMatcher = innerRegex.matcher(outerMatcher.group(1));
    while (innerMatcher.find()) {
        resultList.add(innerMatcher.group());
    }
}</pre>
<pre>List&lt;String&gt; resultList = new ArrayList&lt;String&gt;();
Pattern outerRegex = Pattern.compile("&lt;b&gt;(.*?)&lt;/b&gt;", Pattern.DOTALL);
Pattern innerRegex = Pattern.compile("\\d+");
Matcher outerMatcher = outerRegex.matcher(subjectString);
Matcher innerMatcher = innerRegex.matcher(subjectString);
while (outerMatcher.find()) {
    innerMatcher.region(outerMatcher.start(1), outerMatcher.end(1));
    while (innerMatcher.find()) {
        resultList.add(innerMatcher.group());
    }
}</pre>
<h4>JavaScript</h4>
<pre>var result = [];
var outerRegex = /&lt;b&gt;([\s\S]*?)&lt;\/b&gt;/g;
var innerRegex = /\d+/g;
var outerMatch;
var innerMatches;
while (outerMatch = outerRegex.exec(subject)) {
    if (outerMatch.index == outerRegex.lastIndex)
        outerRegex.lastIndex++;
    innerMatches = outerMatch[1].match(innerRegex);
    if (innerMatches) {
        result = result.concat(innerMatches);
    }
}</pre>
<h4>XRegExp</h4>
<pre>var result = XRegExp.matchChain(subject, [
    {regex: XRegExp("&lt;b&gt;(.*?)&lt;/b&gt;", "s"), backref: 1},
    /\d+/
]);</pre>
<pre>var result = [];
var outerRegex = XRegExp("&lt;b&gt;(.*?)&lt;/b&gt;", "s");
var innerRegex = /\d+/g;
XRegExp.forEach(subject, outerRegex, function(outerMatch) {
    var innerMatches = outerMatch[1].match(innerRegex);
    if (innerMatches) {
        result = result.concat(innerMatches);
    }
});</pre>
<h4>PHP</h4>
<pre>$list = array();
preg_match_all('%&lt;b&gt;(.*?)&lt;/b&gt;%s', $subject, $outermatches,
               PREG_PATTERN_ORDER);
for ($i = 0; $i &lt; count($outermatches[0]); $i++) {
    if (preg_match_all('/\d+/', $outermatches[1][$i], $innermatches,
                       PREG_PATTERN_ORDER)) {
        $list = array_merge($list, $innermatches[0]);
    }
}</pre>
<h4>Perl</h4>
<pre>while ($subject =~ m!&lt;b&gt;(.*?)&lt;/b&gt;!gs) {
    push(@list, ($1 =~ m/\d+/g));
}</pre>
<h4>Python</h4>
<pre>list = []
innerre = re.compile(r"\d+")
for outermatch in re.finditer("(?s)&lt;b&gt;(.*?)&lt;/b&gt;", subject):
    list.extend(innerre.findall(outermatch.group(1)))</pre>
<h4>Ruby</h4>
<pre>list = []
subject.scan(/&lt;b&gt;(.*?)&lt;\/b&gt;/m) {|outergroups|
    list += outergroups[1].scan(/\d+/)
}</pre>
<h3>Discussion</h3>
<pre>\d+(?=(?:(?!&lt;b&gt;).)*&lt;/b&gt;)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>3.14. Replace All Matches</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString = Regex.Replace(subjectString, "before", "after");</pre>
<pre>string resultString = null;
try {
    resultString = Regex.Replace(subjectString, "before", "after");
} catch (ArgumentNullException ex) {
    // Cannot pass null as the regular expression, subject string,
    // or replacement text
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Regex regexObj = new Regex("before");
string resultString = regexObj.Replace(subjectString, "after");</pre>
<pre>string resultString = null;
try {
    Regex regexObj = new Regex("before");
    try {
        resultString = regexObj.Replace(subjectString, "after");
    } catch (ArgumentNullException ex) {
        // Cannot pass null as the subject string or replacement text
    }
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString = Regex.Replace(SubjectString, "before", "after")</pre>
<pre>Dim ResultString As String = Nothing
Try
    ResultString = Regex.Replace(SubjectString, "before", "after")
Catch ex As ArgumentNullException
    'Cannot pass null as the regular expression, subject string,
    'or replacement text
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<pre>Dim RegexObj As New Regex("before")
Dim ResultString = RegexObj.Replace(SubjectString, "after")</pre>
<pre>Dim ResultString As String = Nothing
Try
    Dim RegexObj As New Regex("before")
    Try
        ResultString = RegexObj.Replace(SubjectString, "after")
    Catch ex As ArgumentNullException
       'Cannot pass null as the subject string or replacement text
    End Try
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>String resultString = subjectString.replaceAll("before", "after");</pre>
<pre>try {
    String resultString = subjectString.replaceAll("before", "after");
} catch (PatternSyntaxException ex) {
    // Syntax error in the regular expression
} catch (IllegalArgumentException ex) {
    // Syntax error in the replacement text (unescaped $ signs?)
} catch (IndexOutOfBoundsException ex) {
    // Non-existent backreference used the replacement text
}</pre>
<pre>Pattern regex = Pattern.compile("before");
Matcher regexMatcher = regex.matcher(subjectString);
String resultString = regexMatcher.replaceAll("after");</pre>
<pre>String resultString = null;
try {
    Pattern regex = Pattern.compile("before");
    Matcher regexMatcher = regex.matcher(subjectString);
    try {
        resultString = regexMatcher.replaceAll("after");
    } catch (IllegalArgumentException ex) {
        // Syntax error in the replacement text (unescaped $ signs?)
    } catch (IndexOutOfBoundsException ex) {
        // Non-existent backreference used the replacement text
    }
} catch (PatternSyntaxException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>JavaScript</h4>
<pre>result = subject.replace(/before/g, "after");</pre>
<h4>PHP</h4>
<pre>$result = preg_replace('/before/', 'after', $subject);</pre>
<h4>Perl</h4>
<pre>s/before/after/g;</pre>
<pre>$subject =~ s/before/after/g;</pre>
<pre>($result = $subject) =~ s/before/after/g;</pre>
<h4>Python</h4>
<pre>result = re.sub("before", "after", subject)</pre>
<pre>reobj = re.compile("before")
result = reobj.sub("after", subject)</pre>
<h4>Ruby</h4>
<pre>result = subject.gsub(/before/, 'after')</pre>
<h3>Discussion</h3>
<h4>PHP</h4>
<pre>$regex[0] = '/a/';
$regex[1] = '/b/';
$regex[2] = '/c/';
$replace[2] = '3';
$replace[1] = '2';
$replace[0] = '1';

echo preg_replace($regex, $replace, "abc");
ksort($replace);
echo preg_replace($regex, $replace, "abc");</pre>
<h2>3.15. Replace Matches Reusing Parts of the Match</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString = Regex.Replace(subjectString, @"(\w+)=(\w+)",
                                                   "$2=$1");</pre>
<pre>Regex regexObj = new Regex(@"(\w+)=(\w+)");
string resultString = regexObj.Replace(subjectString, "$2=$1");</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString = Regex.Replace(SubjectString, "(\w+)=(\w+)", "$2=$1")</pre>
<pre>Dim RegexObj As New Regex("(\w+)=(\w+)")
Dim ResultString = RegexObj.Replace(SubjectString, "$2=$1")</pre>
<h4>Java</h4>
<pre>String resultString = subjectString.replaceAll("(\\w+)=(\\w+)", "$2=$1");</pre>
<pre>Pattern regex = Pattern.compile("(\\w+)=(\\w+)");
Matcher regexMatcher = regex.matcher(subjectString);
String resultString = regexMatcher.replaceAll("$2=$1");</pre>
<h4>JavaScript</h4>
<pre>result = subject.replace(/(\w+)=(\w+)/g, "$2=$1");</pre>
<h4>PHP</h4>
<pre>$result = preg_replace('/(\w+)=(\w+)/', '$2=$1', $subject);</pre>
<h4>Perl</h4>
<pre>$subject =~ s/(\w+)=(\w+)/$2=$1/g;</pre>
<h4>Python</h4>
<pre>result = re.sub(r"(\w+)=(\w+)", r"\2=\1", subject)</pre>
<pre>reobj = re.compile(r"(\w+)=(\w+)")
result = reobj.sub(r"\2=\1", subject)</pre>
<h4>Ruby</h4>
<pre>result = subject.gsub(/(\w+)=(\w+)/, '\2=\1')</pre>
<h3>Named Capture</h3>
<h4>C#</h4>
<pre>string resultString = Regex.Replace(subjectString,
                      @"(?&lt;left&gt;\w+)=(?&lt;right&gt;\w+)", "${right}=${left}");</pre>
<pre>Regex regexObj = new Regex(@"(?&lt;left&gt;\w+)=(?&lt;right&gt;\w+)");
string resultString = regexObj.Replace(subjectString, "${right}=${left}");</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString = Regex.Replace(SubjectString,
                   "(?&lt;left&gt;\w+)=(?&lt;right&gt;\w+)", "${right}=${left}")</pre>
<pre>Dim RegexObj As New Regex("(?&lt;left&gt;\w+)=(?&lt;right&gt;\w+)")
Dim ResultString = RegexObj.Replace(SubjectString, "${right}=${left}")</pre>
<h4>Java 7</h4>
<pre>String resultString = subjectString.replaceAll(
                      "(?&lt;left&gt;\\w+)=(?&lt;right&gt;\\w+)", "${right}=${left}");</pre>
<pre>Pattern regex = Pattern.compile("(?&lt;left&gt;\\w+)=(?&lt;right&gt;\\w+)");
Matcher regexMatcher = regex.matcher(subjectString);
String resultString = regexMatcher.replaceAll("${right}=${left}");</pre>
<h4>XRegExp</h4>
<pre>var re = XRegExp("(?&lt;left&gt;\\w+)=(?&lt;right&gt;\\w+)", "g");
var result = XRegExp.replace(subject, re, "${right}=${left}");</pre>
<h4>PHP</h4>
<pre>$result = preg_replace('/(?P&lt;left&gt;\w+)=(?P&lt;right&gt;\w+)/',
                       '$2=$1', $subject);</pre>
<h4>Perl</h4>
<pre>$subject =~ s/(?&lt;left&gt;\w+)=(?&lt;right&gt;\w+)/$+{right}=$+{left}/g;</pre>
<h4>Python</h4>
<pre>result = re.sub(r"(?P&lt;left&gt;\w+)=(?P&lt;right&gt;\w+)", r"\g&lt;right&gt;=\g&lt;left&gt;",
                subject)</pre>
<pre>reobj = re.compile(r"(?P&lt;left&gt;\w+)=(?P&lt;right&gt;\w+)")
result = reobj.sub(r"\g&lt;right&gt;=\g&lt;left&gt;", subject)</pre>
<h4>Ruby</h4>
<pre>result = subject.gsub(/(?&lt;left&gt;\w+)=(?&lt;right&gt;\w+)/, '\k&lt;left&gt;=\k&lt;right&gt;')</pre>
<h2>3.16. Replace Matches with Replacements Generated in Code</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString = Regex.Replace(subjectString, @"\d+",
                      new MatchEvaluator(ComputeReplacement));</pre>
<pre>Regex regexObj = new Regex(@"\d+");
string resultString = regexObj.Replace(subjectString,
                      new MatchEvaluator(ComputeReplacement));</pre>
<pre>public String ComputeReplacement(Match matchResult) {
    int twiceasmuch = int.Parse(matchResult.Value) * 2;
    return twiceasmuch.ToString();
}</pre>
<h4>VB.NET</h4>
<pre>Dim MyMatchEvaluator As New MatchEvaluator(AddressOf ComputeReplacement)
Dim ResultString = Regex.Replace(SubjectString, "\d+", MyMatchEvaluator)</pre>
<pre>Dim RegexObj As New Regex("\d+")
Dim MyMatchEvaluator As New MatchEvaluator(AddressOf ComputeReplacement)
Dim ResultString = RegexObj.Replace(SubjectString, MyMatchEvaluator)</pre>
<pre>Public Function ComputeReplacement(ByVal MatchResult As Match) As String
    Dim TwiceAsMuch = Int.Parse(MatchResult.Value) * 2;
    Return TwiceAsMuch.ToString();
End Function</pre>
<h4>Java</h4>
<pre>StringBuffer resultString = new StringBuffer();
Pattern regex = Pattern.compile("\\d+");
Matcher regexMatcher = regex.matcher(subjectString);
while (regexMatcher.find()) {
    Integer twiceasmuch = Integer.parseInt(regexMatcher.group()) * 2;
    regexMatcher.appendReplacement(resultString, twiceasmuch.toString());
}
regexMatcher.appendTail(resultString);</pre>
<h4>JavaScript</h4>
<pre>var result = subject.replace(/\d+/g, function(match) {
    return match * 2;
});</pre>
<h4>PHP</h4>
<pre>$result = preg_replace_callback('/\d+/', 'compute_replacement', $subject);

function compute_replacement($groups) {
    return $groups[0] * 2;
}</pre>
<pre>$result = preg_replace_callback(
    '/\d+/',
    create_function(
        '$groups',
        'return $groups[0] * 2;'
    ),
    $subject
);</pre>
<h4>Perl</h4>
<pre>$subject =~ s/\d+/$&amp; * 2/eg;</pre>
<h4>Python</h4>
<pre>result = re.sub(r"\d+", computereplacement, subject)</pre>
<pre>reobj = re.compile(r"\d+")
result = reobj.sub(computereplacement, subject)</pre>
<pre>def computereplacement(matchobj):
    return str(int(matchobj.group()) * 2)</pre>
<h4>Ruby</h4>
<pre>result = subject.gsub(/\d+/) {|match|
    Integer(match) * 2
}</pre>
<h2>3.17. Replace All Matches Within the Matches of </h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>Regex outerRegex = new Regex("&lt;b&gt;.*?&lt;/b&gt;", RegexOptions.Singleline);
Regex innerRegex = new Regex("before");
string resultString = outerRegex.Replace(subjectString,
                      new MatchEvaluator(ComputeReplacement));

public String ComputeReplacement(Match matchResult) {
    // Run the inner search-and-replace on each match of the outer regex
    return innerRegex.Replace(matchResult.Value, "after");
}</pre>
<h4>VB.NET</h4>
<pre>Dim OuterRegex As New Regex("&lt;b&gt;.*?&lt;/b&gt;", RegexOptions.Singleline)
Dim InnerRegex As New Regex("before")
Dim MyMatchEvaluator As New MatchEvaluator(AddressOf ComputeReplacement)
Dim ResultString = OuterRegex.Replace(SubjectString, MyMatchEvaluator)

Public Function ComputeReplacement(ByVal MatchResult As Match) As String
    'Run the inner search-and-replace on each match of the outer regex
    Return InnerRegex.Replace(MatchResult.Value, "after");
End Function</pre>
<h4>Java</h4>
<pre>StringBuffer resultString = new StringBuffer();
Pattern outerRegex = Pattern.compile("&lt;b&gt;.*?&lt;/b&gt;");
Pattern innerRegex = Pattern.compile("before");
Matcher outerMatcher = outerRegex.matcher(subjectString);
while (outerMatcher.find()) {
    outerMatcher.appendReplacement(resultString,
      innerRegex.matcher(outerMatcher.group()).replaceAll("after"));
}
outerMatcher.appendTail(resultString);</pre>
<h4>JavaScript</h4>
<pre>var result = subject.replace(/&lt;b&gt;.*?&lt;\/b&gt;/g, function(match) {
    return match.replace(/before/g, "after");
});</pre>
<h4>PHP</h4>
<pre>$result = preg_replace_callback('%&lt;b&gt;.*?&lt;/b&gt;%',
                                replace_within_tag, $subject);

function replace_within_tag($groups) {
    return preg_replace('/before/', 'after', $groups[0]);
}</pre>
<h4>Perl</h4>
<pre>$subject =~ s%&lt;b&gt;.*?&lt;/b&gt;%($match = $&amp;) =~ s/before/after/g; $match;%eg;</pre>
<h4>Python</h4>
<pre>innerre = re.compile("before")
def replacewithin(matchobj):
    return innerre.sub("after", matchobj.group())

result = re.sub("&lt;b&gt;.*?&lt;/b&gt;", replacewithin, subject)</pre>
<h4>Ruby</h4>
<pre>innerre = /before/
result = subject.gsub(/&lt;b&gt;.*?&lt;\/b&gt;/) {|match|
    match.gsub(innerre, 'after')
}</pre>
<h2>3.18. Replace All Matches Between the Matches of Another Regex</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString = null;
Regex outerRegex = new Regex("&lt;[^&lt;&gt;]*&gt;");
Regex innerRegex = new Regex("\"([^\"]*)\"");
// Find the first section
int lastIndex = 0;
Match outerMatch = outerRegex.Match(subjectString);
while (outerMatch.Success) {
    // Search and replace through the text between this match,
    // and the previous one
	string textBetween =
	    subjectString.Substring(lastIndex, outerMatch.Index - lastIndex);
	resultString += innerRegex.Replace(textBetween, "\u201C$1\u201D");
	lastIndex = outerMatch.Index + outerMatch.Length;
	// Copy the text in the section unchanged
	resultString += outerMatch.Value;
	// Find the next section
	outerMatch = outerMatch.NextMatch();
}
// Search and replace through the remainder after the last regex match
string textAfter = subjectString.Substring(lastIndex,
                   subjectString.Length - lastIndex);
resultString += innerRegex.Replace(textAfter, "\u201C$1\u201D");</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString As String = Nothing
Dim OuterRegex As New Regex("&lt;[^&lt;&gt;]*&gt;")
Dim InnerRegex As New Regex("""([^""]*)""")
'Find the first section
Dim LastIndex = 0
Dim OuterMatch = OuterRegex.Match(SubjectString)
While OuterMatch.Success
    'Search and replace through the text between this match, 
    'and the previous one
    Dim TextBetween = SubjectString.Substring(LastIndex, 
                      OuterMatch.Index - LastIndex);
    ResultString += InnerRegex.Replace(TextBetween, 
                    ChrW(&amp;H201C) + "$1" + ChrW(&amp;H201D))
    LastIndex = OuterMatch.Index + OuterMatch.Length
    'Copy the text in the section unchanged
    ResultString += OuterMatch.Value
    'Find the next section
    OuterMatch = OuterMatch.NextMatch
End While
'Search and replace through the remainder after the last regex match
Dim TextAfter = SubjectString.Substring(LastIndex,
                                        SubjectString.Length - LastIndex);
ResultString += InnerRegex.Replace(TextAfter, 
                ChrW(&amp;H201C) + "$1" + ChrW(&amp;H201D))</pre>
<h4>Java</h4>
<pre>StringBuffer resultString = new StringBuffer();
Pattern outerRegex = Pattern.compile("&lt;[^&lt;&gt;]*&gt;");
Pattern innerRegex = Pattern.compile("\"([^\"]*)\"");
Matcher outerMatcher = outerRegex.matcher(subjectString);
int lastIndex = 0;
while (outerMatcher.find()) {
    // Search and replace through the text between this match,
    // and the previous one
    String textBetween = subjectString.substring(lastIndex,
                                                 outerMatcher.start());
    Matcher innerMatcher = innerRegex.matcher(textBetween);
    resultString.append(innerMatcher.replaceAll("\u201C$1\u201D"));
    lastIndex = outerMatcher.end();
    // Append the regex match itself unchanged
    resultString.append(outerMatcher.group());
}
// Search and replace through the remainder after the last regex match
String textAfter = subjectString.substring(lastIndex);
Matcher innerMatcher = innerRegex.matcher(textAfter);
resultString.append(innerMatcher.replaceAll("\u201C$1\u201D"));</pre>
<h4>JavaScript</h4>
<pre>var result = "";
var outerRegex = /&lt;[^&lt;&gt;]*&gt;/g;
var innerRegex = /"([^"]*)"/g;
var outerMatch = null;
var lastIndex = 0;
while (outerMatch = outerRegex.exec(subject)) {
    if (outerMatch.index == outerRegex.lastIndex) outerRegex.lastIndex++;
    // Search and replace through the text between this match,
    // and the previous one
    var textBetween = subject.slice(lastIndex, outerMatch.index);
    result += textBetween.replace(innerRegex, "\u201C$1\u201D");
    lastIndex = outerMatch.index + outerMatch[0].length;
    // Append the regex match itself unchanged
    result += outerMatch[0];
}
// Search and replace through the remainder after the last regex match
var textAfter = subject.slice(lastIndex);
result += textAfter.replace(innerRegex, "\u201C$1\u201D");</pre>
<h4>PHP</h4>
<pre>$result = '';
$lastindex = 0;
while (preg_match('/&lt;[^&lt;&gt;]*&gt;/', $subject, $groups, PREG_OFFSET_CAPTURE, 
                 $lastindex)) {
    $matchstart = $groups[0][1];
    $matchlength = strlen($groups[0][0]);
    // Search and replace through the text between this match,
    // and the previous one
    $textbetween = substr($subject, $lastindex, $matchstart-$lastindex);
    $result .= preg_replace('/"([^"]*)"/', '“$1”', $textbetween);
    // Append the regex match itself unchanged
    $result .= $groups[0][0];
    // Move the starting position for the next match
    $lastindex = $matchstart + $matchlength;
    if ($matchlength == 0) {
        // Don't get stuck in an infinite loop
        // if the regex allows zero-length matches
        $lastindex++;
    }
}
// Search and replace through the remainder after the last regex match
$textafter = substr($subject, $lastindex);
$result .= preg_replace('/"([^"]*)"/', '“$1”', $textafter);</pre>
<h4>Perl</h4>
<pre>use encoding "utf-8";
$result = '';
while ($subject =~ m/&lt;[^&lt;&gt;]*&gt;/g) {
    $match = $&amp;;
    $textafter = $';
    ($textbetween = $`) =~ s/"([^"]*)"/\x{201C}$1\x{201D}/g;
    $result .= $textbetween . $match;
}
$textafter =~ s/"([^"]*)"/\x{201C}$1\x{201D}/g;
$result .= $textafter;</pre>
<h4>Python</h4>
<pre>innerre = re.compile('"([^"]*)"')
result = "";
lastindex = 0;
for outermatch in re.finditer("&lt;[^&lt;&gt;]*&gt;", subject):
    # Search and replace through the text between this match,
    # and the previous one
    textbetween = subject[lastindex:outermatch.start()]
    result += innerre.sub(u"\u201C\\1\u201D", textbetween)
    lastindex = outermatch.end()
    # Append the regex match itself unchanged
    result += outermatch.group()
# Search and replace through the remainder after the last regex match
textafter = subject[lastindex:]
result += innerre.sub(u"\u201C\\1\u201D", textafter)</pre>
<h4>Ruby</h4>
<pre>result = '';
textafter = ''
subject.scan(/&lt;[^&lt;&gt;]*&gt;/) {|match|
    textafter = $'
    textbetween = $`.gsub(/"([^"]*)"/, '“\1”')
    result += textbetween + match
}
result += textafter.gsub(/"([^"]*)"/, '“\1”')</pre>
<h3>Discussion</h3>
<h4>Python</h4>
<pre>print result.encode('1252')</pre>
<h2>3.19. Split a String</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string[] splitArray = Regex.Split(subjectString, "&lt;[^&lt;&gt;]*&gt;");</pre>
<pre>string[] splitArray = null;
try {
    splitArray = Regex.Split(subjectString, "&lt;[^&lt;&gt;]*&gt;");
} catch (ArgumentNullException ex) {
     // Cannot pass null as the regular expression or subject string
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Regex regexObj = new Regex("&lt;[^&lt;&gt;]*&gt;");
string[] splitArray = regexObj.Split(subjectString);</pre>
<pre>string[] splitArray = null;
try {
    Regex regexObj = new Regex("&lt;[^&lt;&gt;]*&gt;");
    try {
        splitArray = regexObj.Split(subjectString);
    } catch (ArgumentNullException ex) {
        // Cannot pass null as the subject string
    }
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim SplitArray = Regex.Split(SubjectString, "&lt;[^&lt;&gt;]*&gt;")</pre>
<pre>Dim SplitArray As String()
Try
    SplitArray = Regex.Split(SubjectString, "&lt;[^&lt;&gt;]*&gt;")
Catch ex As ArgumentNullException
    'Cannot pass null as the regular expression or subject string
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<pre>Dim RegexObj As New Regex("&lt;[^&lt;&gt;]*&gt;")
Dim SplitArray = RegexObj.Split(SubjectString)</pre>
<pre>Dim SplitArray As String()
Try
    Dim RegexObj As New Regex("&lt;[^&lt;&gt;]*&gt;")
    Try
        SplitArray = RegexObj.Split(SubjectString)
    Catch ex As ArgumentNullException
        'Cannot pass null as the subject string
    End Try
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>String[] splitArray = subjectString.split("&lt;[^&lt;&gt;]*&gt;");</pre>
<pre>try {
    String[] splitArray = subjectString.split("&lt;[^&lt;&gt;]*&gt;");
} catch (PatternSyntaxException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Pattern regex = Pattern.compile("&lt;[^&lt;&gt;]*&gt;");
String[] splitArray = regex.split(subjectString);</pre>
<pre>String[] splitArray = null;
try {
    Pattern regex = Pattern.compile("&lt;[^&lt;&gt;]*&gt;");
    splitArray = regex.split(subjectString);
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>JavaScript</h4>
<pre>result = subject.split(/&lt;[^&lt;&gt;]*&gt;/);</pre>
<h4>XRegExp</h4>
<pre>result = XRegExp.split(subject, /&lt;[^&lt;&gt;]*&gt;/);</pre>
<h4>PHP</h4>
<pre>$result = preg_split('/&lt;[^&lt;&gt;]*&gt;/', $subject);</pre>
<h4>Perl</h4>
<pre>@result = split(m/&lt;[^&lt;&gt;]*&gt;/, $subject);</pre>
<h4>Python</h4>
<pre>result = re.split("&lt;[^&lt;&gt;]*&gt;", subject))</pre>
<pre>reobj = re.compile("&lt;[^&lt;&gt;]*&gt;")
result = reobj.split(subject)</pre>
<h4>Ruby</h4>
<pre>result = subject.split(/&lt;[^&lt;&gt;]*&gt;/)</pre>
<h2>3.20. Split a String, Keeping the Regex Matches</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string[] splitArray = Regex.Split(subjectString, "(&lt;[^&lt;&gt;]*&gt;)");</pre>
<pre>Regex regexObj = new Regex("(&lt;[^&lt;&gt;]*&gt;)");
string[] splitArray = regexObj.Split(subjectString);</pre>
<h4>VB.NET</h4>
<pre>Dim SplitArray = Regex.Split(SubjectString, "(&lt;[^&lt;&gt;]*&gt;)")</pre>
<pre>Dim RegexObj As New Regex("(&lt;[^&lt;&gt;]*&gt;)")
Dim SplitArray = RegexObj.Split(SubjectString)</pre>
<h4>Java</h4>
<pre>List&lt;String&gt; resultList = new ArrayList&lt;String&gt;();
Pattern regex = Pattern.compile("&lt;[^&lt;&gt;]*&gt;");
Matcher regexMatcher = regex.matcher(subjectString);
int lastIndex = 0;
while (regexMatcher.find()) {
    resultList.add(subjectString.substring(lastIndex,
                                           regexMatcher.start()));
    resultList.add(regexMatcher.group());
    lastIndex = regexMatcher.end();
}
resultList.add(subjectString.substring(lastIndex));</pre>
<h4>JavaScript</h4>
<pre>result = subject.split(/(&lt;[^&lt;&gt;]*&gt;)/);</pre>
<h4>XRegExp</h4>
<pre>result = XRegExp.split(subject, /(&lt;[^&lt;&gt;]*&gt;)/);</pre>
<h4>PHP</h4>
<pre>$result = preg_split('/(&lt;[^&lt;&gt;]*&gt;)/', $subject, -1,
                     PREG_SPLIT_DELIM_CAPTURE);</pre>
<h4>Perl</h4>
<pre>@result = split(m/(&lt;[^&lt;&gt;]*&gt;)/, $subject);</pre>
<h4>Python</h4>
<pre>result = re.split("(&lt;[^&lt;&gt;]*&gt;)", subject))</pre>
<pre>reobj = re.compile("(&lt;[^&lt;&gt;]*&gt;)")
result = reobj.split(subject)</pre>
<h4>Ruby</h4>
<pre>list = []
lastindex = 0;
subject.scan(/&lt;[^&lt;&gt;]*&gt;/) {|match|
    list &lt;&lt; subject[lastindex..$~.begin(0)-1];
    list &lt;&lt; $&amp;
    lastindex = $~.end(0)
}
list &lt;&lt; subject[lastindex..subject.length()]</pre>
<h2>3.21. Search Line by Line</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string[] lines = Regex.Split(subjectString, "\r?\n");</pre>
<pre>Regex regexObj = new Regex("regex pattern");
for (int i = 0; i &lt; lines.Length; i++) {
    if (regexObj.IsMatch(lines[i])) {
        // The regex matches lines[i]
    } else {
        // The regex does not match lines[i]
    }
}</pre>
<h4>VB.NET</h4>
<pre>Dim Lines = Regex.Split(SubjectString, "\r?\n")</pre>
<pre>Dim RegexObj As New Regex("regex pattern")
For i As Integer = 0 To Lines.Length - 1
    If RegexObj.IsMatch(Lines(i)) Then
        'The regex matches Lines(i)
    Else
        'The regex does not match Lines(i)
    End If
Next</pre>
<h4>Java</h4>
<pre>String[] lines = subjectString.split("\r?\n");</pre>
<pre>Pattern regex = Pattern.compile("regex pattern");
Matcher regexMatcher = regex.matcher("");
for (int i = 0; i &lt; lines.length; i++) {
    regexMatcher.reset(lines[i]);
    if (regexMatcher.find()) {
        // The regex matches lines[i]
    } else {
        // The regex does not match lines[i]
    }
}</pre>
<h4>JavaScript</h4>
<pre>var lines = subject.split(/\r?\n/);</pre>
<pre>var regexp = /regex pattern/;
for (var i = 0; i &lt; lines.length; i++) {
    if (lines[i].match(regexp)) {
        // The regex matches lines[i]
    } else {
        // The regex does not match lines[i]
    }
}</pre>
<h4>PHP</h4>
<pre>$lines = preg_split('/\r?\n/', $subject)</pre>
<pre>foreach ($lines as $line) {
    if (preg_match('/regex pattern/', $line)) {
        // The regex matches $line
    } else {
        // The regex does not match $line
    }
}</pre>
<h4>Perl</h4>
<pre>@lines = split(m/\r?\n/, $subject)</pre>
<pre>foreach $line (@lines) {
    if ($line =~ m/regex pattern/) {
        # The regex matches $line
    } else {
        # The regex does not match $line
    }
}</pre>
<h4>Python</h4>
<pre>lines = re.split("\r?\n", subject)</pre>
<pre>reobj = re.compile("regex pattern")
for line in lines[:]:
    if reobj.search(line):
        # The regex matches line
    else:
        # The regex does not match line</pre>
<h4>Ruby</h4>
<pre>lines = subject.split(/\r?\n/)</pre>
<pre>re = /regex pattern/
lines.each { |line|
    if line =~ re
        # The regex matches line
    else
        # The regex does not match line
}</pre>
<h2>3.22. Construct a Parser</h2>
<h3>Problem</h3>
<pre>table %First table%
  row cell %A1% cell %B1% cell%C1%cell%D1%
  ROW row CELL %The previous row was blank%
  cell %B3%
  row
    cell %A4% %second line%
    cEll %B4%
         %second line%
    cell %C4
second line%
  row cell %%%string%%%
    cell %%
    cell %%%%
    cell %%%%%%</pre>
<h3>Solution</h3>
<h4>C#</h4>
<pre>static RECTable ImportTable(string fileContents) {
  RECTable table = null;
  RECRow row = null;
  RECCell cell = null;
  Regex regexObj = new Regex(
      @"  \b(?&lt;keyword&gt;table|row|cell)\b
      | %(?&lt;string&gt;[^%]*(?:%%[^%]*)*)%
      | (?&lt;error&gt;\S+)",
    RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace);
  Match match = regexObj.Match(fileContents);
  while (match.Success) {
    if (match.Groups["keyword"].Success) {
      string keyword = match.Groups["keyword"].Value.ToLower();
      if (keyword == "table") {
        table = new RECTable();
        row = null;
        cell = null;
      } else if (keyword == "row") {
        if (table == null)
          throw new Exception("Invalid data: row without table");
        row = table.addRow();
        cell = null;
      } else if (keyword == "cell") {
        if (row == null)
          throw new Exception("Invalid data: cell without row");
        cell = row.addCell();
      } else {
        throw new Exception("Parser bug: unknown keyword");
      }
    } else if (match.Groups["string"].Success) {
      string content = match.Groups["string"].Value.Replace("%%", "%");
      if (cell != null)
        cell.addContent(content);
      else if (row != null)
        throw new Exception("Invalid data: string after row keyword");
      else if (table != null)
        table.addCaption(content);
      else
        throw new Exception("Invalid data: string before table keyword");
    } else if (match.Groups["error"].Success) {
      throw new Exception("Invalid data: " + match.Groups["error"].Value);
    } else {
      throw new Exception("Parser bug: no capturing group matched");
    }
    match = match.NextMatch();
  }
  if (table == null)
    throw new Exception("Invalid data: table keyword missing");
  return table;
}</pre>
<h4>VB.NET</h4>
<pre>Function ImportTable(ByVal FileContents As String)
  Dim Table As RECTable = Nothing
  Dim Row As RECRow = Nothing
  Dim Cell As RECCell = Nothing
  Dim RegexObj As New Regex(
      "  \b(?&lt;keyword&gt;table|row|cell)\b" &amp; _
      "| %(?&lt;string&gt;[^%]*(?:%%[^%]*)*)%" &amp; _
      "| (?&lt;error&gt;\S+)",
      RegexOptions.IgnoreCase Or RegexOptions.IgnorePatternWhitespace)
  Dim MatchResults As Match = RegexObj.Match(FileContents)
  While MatchResults.Success
    If MatchResults.Groups("keyword").Success Then
      Dim Keyword As String = MatchResults.Groups("keyword").Value
      Keyword = Keyword.ToLower()
      If Keyword = "table" Then
        Table = New RECTable
        Row = Nothing
        Cell = Nothing
      ElseIf Keyword = "row" Then
        If Table Is Nothing Then
          Throw New Exception("Invalid data: row without table")
        End If
        Row = Table.addRow
        Cell = Nothing
      ElseIf Keyword = "cell" Then
        If Row Is Nothing Then
          Throw New Exception("Invalid data: cell without row")
        End If
        Cell = Row.addCell
      Else
        Throw New Exception("Parser bug: unknown keyword")
      End If
    ElseIf MatchResults.Groups("string").Success Then
      Dim Content As String = MatchResults.Groups("string").Value
      Content = Content.Replace("%%", "%")
      If Cell IsNot Nothing Then
        Cell.addContent(Content)
      ElseIf Row IsNot Nothing Then
        Throw New Exception("Invalid data: string after row keyword")
      ElseIf Table IsNot Nothing Then
        Table.addCaption(Content)
      Else
        Throw New Exception("Invalid data: string before table keyword")
      End If
    ElseIf MatchResults.Groups("error").Success Then
      Throw New Exception("Invalid data")
    Else
      Throw New Exception("Parser bug: no capturing group matched")
    End If
    MatchResults = MatchResults.NextMatch()
  End While
  If Table Is Nothing Then
    Throw New Exception("Invalid data: table keyword missing")
  End If
  Return Table
End Function</pre>
<h4>Java</h4>
<pre>RECTable ImportTable(String fileContents) throws Exception {
  RECTable table = null;
  RECRow row = null;
  RECCell cell = null;
  final int groupkeyword = 1;
  final int groupstring = 2;
  final int grouperror = 3;
  Pattern regex = Pattern.compile(
      "  \\b(table|row|cell)\\b\n" +
      "| %([^%]*(?:%%[^%]*)*)%\n" +
      "| (\\S+)",
      Pattern.CASE_INSENSITIVE | Pattern.COMMENTS);
  Matcher regexMatcher = regex.matcher(fileContents);
  while (regexMatcher.find()) {
    if (regexMatcher.start(groupkeyword) &gt;= 0) {
      String keyword = regexMatcher.group(groupkeyword).toLowerCase();
      if (keyword.equals("table")) {
        table = new RECTable();
        row = null;
        cell = null;
      } else if (keyword.equals("row")) {
        if (table == null)
          throw new Exception("Invalid data: row without table");
        row = table.addRow();
        cell = null;
      } else if (keyword.equals("cell")) {
        if (row == null)
          throw new Exception("Invalid data: cell without row");
        cell = row.addCell();
      } else {
        throw new Exception("Parser bug: unknown keyword");
      }
    } else if (regexMatcher.start(groupstring) &gt;= 0) {
      String content = regexMatcher.group(groupstring);
      content = content.replaceAll("%%", "%");
      if (cell != null)
        cell.addContent(content);
      else if (row != null)
        throw new Exception("Invalid data: String after row keyword");
      else if (table != null)
        table.addCaption(content);
      else
        throw new Exception("Invalid data: String before table keyword");
    } else if (regexMatcher.start(grouperror) &gt;= 0) {
      throw new Exception("Invalid data: " + 
                          regexMatcher.group(grouperror));
    } else {
      throw new Exception("Parser bug: no capturing group matched");
    }
  }
  if (table == null)
    throw new Exception("Invalid data: table keyword missing");
  return table;
}</pre>
<h4>JavaScript</h4>
<pre>function importTable(fileContents) {
  var table = null;
  var row = null;
  var cell = null;
  var groupkeyword = 1;
  var groupstring = 2;
  var grouperror = 3;
  var myregexp = /\b(table|row|cell)\b|%([^%]*(?:%%[^%]*)*)%|(\S+)/ig;
  var match;
  var keyword;
  var content;
  while (match = myregexp.exec(fileContents)) {
    if (match[groupkeyword] !== undefined) {
      keyword = match[groupkeyword].toLowerCase();
      if (keyword == "table") {
        table = new RECTable();
        row = null;
        cell = null;
      } else if (keyword == "row") {
        if (!table)
          throw new Error("Invalid data: row without table");
        row = table.addRow();
        cell = null;
      } else if (keyword == "cell") {
        if (!row)
          throw new Error("Invalid data: cell without row");
        cell = row.addCell();
      } else {
        throw new Error("Parser bug: unknown keyword");
      }
    } else if (match[groupstring] !== undefined) {
      content = match[groupstring].replace(/%%/g, "%");
      if (cell)
        cell.addContent(content);
      else if (row)
        throw new Error("Invalid data: string after row keyword");
      else if (table)
        table.addCaption(content);
      else
        throw new Error("Invalid data: string before table keyword");
    } else if (match[grouperror] !== undefined) {
      throw new Error("Invalid data: " + match[grouperror]);
    } else {
      throw new Error("Parser bug: no capturing group matched");
    }
  }
  if (!table)
    throw new Error("Invalid data: table keyword missing");
  return table;
}</pre>
<h4>XRegExp</h4>
<pre>function importTable(fileContents) {
  var table = null;
  var row = null;
  var cell = null;
  var myregexp = XRegExp("(?ix)\\b(?&lt;keyword&gt;table|row|cell)\\b" +
                         "   | %(?&lt;string&gt;[^%]*(?:%%[^%]*)*)%" +
                         "   | (?&lt;error&gt;\\S+)");
  XRegExp.forEach(fileContents, myregexp, function(match) {
    var keyword;
    var content;
    if (match.keyword !== undefined) {
      keyword = match.keyword.toLowerCase();
      if (keyword == "table") {
        table = new RECTable();
        row = null;
        cell = null;
      } else if (keyword == "row") {
        if (!table)
          throw new Error("Invalid data: row without table");
        row = table.addRow();
        cell = null;
      } else if (keyword == "cell") {
        if (!row)
          throw new Error("Invalid data: cell without row");
        cell = row.addCell();
      } else {
        throw new Error("Parser bug: unknown keyword");
      }
    } else if (match.string !== undefined) {
      content = match.string.replace(/%%/g, "%");
      if (cell)
        cell.addContent(content);
      else if (row)
        throw new Error("Invalid data: string after row keyword");
      else if (table)
        table.addCaption(content);
      else
        throw new Error("Invalid data: string before table keyword");
    } else if (match.error !== undefined) {
      throw new Error("Invalid data: " + match.error);
    } else {
      throw new Error("Parser bug: no capturing group matched");
    }
  });
  if (!table)
    throw new Error("Invalid data: table keyword missing");
  return table;
}</pre>
<h4>Perl</h4>
<pre>sub importtable {
  my $filecontents = shift;
  my $table;
  my $row;
  my $cell;
  while ($filecontents =~ 
          m/  \b(table|row|cell)\b
          | %([^%]*(?:%%[^%]*)*)%
          | (\S+)/ixg) {
    if (defined($1)) { # Keyword
      my $keyword = lc($1);
      if ($keyword eq "table") {
        $table = new RECTable();
        undef $row;
        undef $cell;
      } elsif ($keyword eq "row") {
        if (!defined($table)) {
          die "Invalid data: row without table";
        }
        $row = $table-&gt;addRow();
        undef $cell;
      } elsif ($keyword eq "cell") {
        if (!defined($row)) {
          die "Invalid data: cell without row";
        }
        $cell = $row-&gt;addCell();
      } else {
        die "Parser bug: unknown keyword";
      }
    } elsif (defined($2)) { # String
      my $content = $2;
      $content =~ s/%%/%/g;
      if (defined($cell)) {
        $cell-&gt;addContent($content);
      } elsif (defined($row)) {
        die "Invalid data: string after row keyword";
      } elsif (defined($table)) {
        $table-&gt;addCaption($content);
      } else {
        die "Invalid data: string before table keyword";
      }
    } elsif (defined($3)) { # Error
      die "Invalid data: $3";
    } else {
      die "Parser bug: no capturing group matched";
    }
  }
  if (!defined(table)) {
    die "Invalid data: table keyword missing";
  }
  return table;
}</pre>
<h4>Python</h4>
<pre>def importtable(filecontents):
  table = None
  row = None
  cell = None
  for match in re.finditer(
    r"""(?ix)\b(?P&lt;keyword&gt;table|row|cell)\b
             | %(?P&lt;string&gt;[^%]*(?:%%[^%]*)*)%
             | (?P&lt;error&gt;\S+)""", filecontents):
    if match.group("keyword") != None:
      keyword = match.group("keyword").lower()
      if keyword == "table":
        table = RECTable()
        row = None
        cell = None
      elif keyword == "row":
        if table == None:
          raise Exception("Invalid data: row without table")
        row = table.addRow()
        cell = None
      elif keyword == "cell":
        if row == None:
          raise Exception("Invalid data: cell without row")
        cell = row.addCell()
      else:
        raise Exception("Parser bug: unknown keyword")
    elif match.group("string") != None:
      content = match.group("string").replace("%%", "%")
      if cell != None:
        cell.addContent(content)
      elif row != None:
        raise Exception("Invalid data: string after row keyword")
      elif table != None:
        table.addCaption(content)
      else:
        raise Exception("Invalid data: string before table keyword")
    elif match.group("error") != None:
      raise Exception("Invalid data: " + match.group("error"))
    else:
      raise Exception("Parser bug: no capturing group matched")
  if table == None:
    raise Exception("Invalid data: table keyword missing")
  return table</pre>
<h4>PHP</h4>
<pre>function importTable($fileContents) {
  preg_match_all(
    '/  \b(?P&lt;keyword&gt;table|row|cell)\b
      | (?P&lt;string&gt;%[^%]*(?:%%[^%]*)*%)
      | (?P&lt;error&gt;\S+)/ix',
    $fileContents, $matches, PREG_PATTERN_ORDER);
  $table = NULL;
  $row = NULL;
  $cell = NULL;
  for ($i = 0; $i &lt; count($matches[0]); $i++) {
    if ($matches['keyword'][$i] != NULL) {
      $keyword = strtolower($matches['keyword'][$i]);
      if ($keyword == "table") {
        $table = new RECTable();
        $row = NULL;
        $cell = NULL;
      } elseif ($keyword == "row") {
        if ($table == NULL)
          throw new Exception("Invalid data: row without table");
        $row = $table-&gt;addRow();
        $cell = NULL;
      } elseif ($keyword == "cell") {
        if ($row == NULL)
          throw new Exception("Invalid data: cell without row");
        $cell = $row-&gt;addCell();
      } else {
        throw new Exception("Parser bug: unknown keyword");
      }
    } elseif ($matches['string'][$i] != NULL) {
      $content = $matches['string'][$i];
      $content = substr($content, 1, strlen($content)-2);
      $content = str_replace('%%', '%', $content);
      if ($cell != NULL)
        $cell-&gt;addContent($content);
      elseif ($row != NULL)
        throw new Exception("Invalid data: string after row keyword");
      elseif ($table != NULL)
        $table-&gt;addCaption($content);
      else
        throw new Exception("Invalid data: string before table keyword");
    } elseif ($matches['error'][$i] != NULL) {
      throw new Exception("Invalid data: " + $matches['error'][$i]);
    } else {
      throw new Exception("Parser bug: no capturing group matched");
    }
  }
  if ($table == NULL)
    throw new Exception("Invalid data: table keyword missing");
  return $table;
}</pre>
<h4>Ruby</h4>
<pre>def importtable(filecontents)
  table = nil
  row = nil
  cell = nil
  groupkeyword = 0;
  groupstring = 1;
  grouperror = 2;
  regexp = /  \b(table|row|cell)\b
            | %([^%]*(?:%%[^%]*)*)%
            | (\S+)/ix
  filecontents.scan(regexp) do |match|
    if match[groupkeyword]
      keyword = match[groupkeyword].downcase
      if keyword == "table"
        table = RECTable.new()
        row = nil
        cell = nil
      elsif keyword == "row"
        if table.nil?
          raise "Invalid data: row without table"
        end
        row = table.addRow()
        cell = nil
      elsif keyword == "cell"
        if row.nil?
          raise "Invalid data: cell without row"
        end
        cell = row.addCell()
      else
        raise "Parser bug: unknown keyword"
      end
    elsif not match[groupstring].nil?
      content = match[groupstring].gsub("%%", "%")
      if not cell.nil?
        cell.addContent(content)
      elsif not row.nil?
        raise "Invalid data: string after row keyword"
      elsif not table.nil?
        table.addCaption(content)
      else
        raise "Invalid data: string before table keyword"
      end
    elsif not match[grouperror].nil?
      raise "Invalid data: " + match.group("error")
    else
      raise "Parser bug: no capturing group matched"
    end
  end
  if table.nil?
    raise "Invalid data: table keyword missing"
  end
  return table
end</pre>
<h3>Discussion</h3>
<pre>  \b(?&lt;keyword&gt;table|row|cell)\b
| %(?&lt;string&gt;[^%]*(?:%%[^%]*)*)%
| (?&lt;error&gt;\S+)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>  \b(?P&lt;keyword&gt;table|row|cell)\b
| %(?P&lt;string&gt;[^%]*(?:%%[^%]*)*)%
| (?P&lt;error&gt;\S+)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
        and later, Perl 5.10, Python</p>
<pre>  \b(table|row|cell)\b
| %([^%]*(?:%%[^%]*)*)%
| (\S+)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>\b(table|row|cell)\b|%([^%]*+(?:%%[^%]*+)*+)%|(\S+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h1>4. Validation and Formatting</h1>
<h2>4.1. Validate Email Addresses</h2>
<h3>Solution</h3>
<h4>Simple</h4>
<pre>^\S+@\S+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A\S+@\S+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Simple, with restrictions on characters</h4>
<pre>^[A-Z0-9+_.-]+@[A-Z0-9.-]+$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A[A-Z0-9+_.-]+@[A-Z0-9.-]+\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Simple, with all valid local part characters</h4>
<pre>^[A-Z0-9_!#$%&amp;'*+/=?`{|}~^.-]+@[A-Z0-9.-]+$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A[A-Z0-9_!#$%&amp;'*+/=?`{|}~^.-]+@[A-Z0-9.-]+\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>No leading, trailing, or consecutive dots</h4>
<pre>^[A-Z0-9_!#$%&amp;'*+/=?`{|}~^-]+(?:\.[A-Z0-9_!#$%&amp;'*+/=?`{|}~^-]+)*@[A-Z0-9-]+(?:\.[A-Z0-9-]+)*$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A[A-Z0-9_!#$%&amp;'*+/=?`{|}~^-]+(?:\.[A-Z0-9_!#$%&amp;'*+/=?`{|}~^-]+)*@[A-Z0-9-]+(?:\.[A-Z0-9-]+)*\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Top-level domain has two to six letters</h4>
<pre>^[\w!#$%&amp;'*+/=?`{|}~^-]+(?:\.[\w!#$%&amp;'*+/=?`{|}~^-]+)*@(?:[A-Z0-9-]+\.)+[A-Z]{2,6}$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A[\w!#$%&amp;'*+/=?`{|}~^-]+(?:\.[\w!#$%&amp;'*+/=?`{|}~^-]+)*@(?:[A-Z0-9-]+\.)+[A-Z]{2,6}\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h2>4.2. Validate and Format North American Phone Numbers</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>($1) $2-$3</pre>
<pre>(\1) \2-\3</pre>
<h4>C# example</h4>
<pre>Regex phoneRegex =
    new Regex(@"^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$");

if (phoneRegex.IsMatch(subjectString)) {
    string formattedPhoneNumber =
        phoneRegex.Replace(subjectString, "($1) $2-$3");
} else {
    // Invalid phone number
}</pre>
<h4>JavaScript example</h4>
<pre>var phoneRegex = /^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/;

if (phoneRegex.test(subjectString)) {
    var formattedPhoneNumber =
        subjectString.replace(phoneRegex, "($1) $2-$3");
} else {
    // Invalid phone number
}</pre>
<h3>Discussion</h3>
<pre>^        # Assert position at the beginning of the string.
\(       # Match a literal "("
  ?      #   between zero and one time.
(        # Capture the enclosed match to backreference 1:
  [0-9]  #   Match a digit
    {3}  #     exactly three times.
)        # End capturing group 1.
\)       # Match a literal ")"
  ?      #   between zero and one time.
[-. ]    # Match one hyphen, dot, or space
  ?      #   between zero and one time.
…       # [Match the remaining digits and separator.]
$        # Assert position at the end of the string.</pre>
<h3>Variations</h3>
<h4>Eliminate invalid phone numbers</h4>
<pre>^\(?([2-9][0-8][0-9])\)?[-. ]?([2-9][0-9]{2})[-. ]?([0-9]{4})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Find phone numbers in documents</h4>
<pre>\(?\b([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Allow a leading “1”</h4>
<pre>^(?:\+?1[-. ]?)?\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Allow seven-digit phone numbers</h4>
<pre>^(?:\(?([0-9]{3})\)?[-. ]?)?([0-9]{3})[-. ]?([0-9]{4})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.3. Validate International Phone Numbers</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^\+(?:[0-9] ?){6,14}[0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>JavaScript example</h4>
<pre>function validate(phone) {
    var regex = /^\+(?:[0-9] ?){6,14}[0-9]$/;

    if (regex.test(phone)) {
        // Valid international phone number
    } else {
        // Invalid international phone number
    }
}</pre>
<h3>Discussion</h3>
<pre>^         # Assert position at the beginning of the string.
\+        # Match a literal "+" character.
(?:       # Group but don't capture:
  [0-9]   #   Match a digit.
  \x20    #   Match a space character
    ?     #     between zero and one time.
)         # End the noncapturing group.
  {6,14}  #   Repeat the group between 6 and 14 times.
[0-9]     # Match a digit.
$         # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Validate international phone numbers in EPP format</h4>
<pre>^\+[0-9]{1,3}\.[0-9]{4,14}(?:x.+)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.4. Validate Traditional Date Formats</h2>
<h3>Solution</h3>
<pre>^[0-3]?[0-9]/[0-3]?[0-9]/(?:[0-9]{2})?[0-9]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[0-3][0-9]/[0-3][0-9]/(?:[0-9][0-9])?[0-9][0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-2]|0?[1-9])/(3[01]|[12][0-9]|0?[1-9])/(?:[0-9]{2})?[0-9]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])/[0-9]{4}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[01]|[12][0-9]|0?[1-9])/(1[0-2]|0?[1-9])/(?:[0-9]{2})?[0-9]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[01]|[12][0-9]|0[1-9])/(1[0-2]|0[1-9])/[0-9]{4}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(1[0-2]|0?[1-9])/(3[01]|[12][0-9]|0?[1-9])|(3[01]|[12][0-9]|0?[1-9])/(1[0-2]|0?[1-9]))/(?:[0-9]{2})?[0-9]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:
  # m/d or mm/dd
  (1[0-2]|0?[1-9])/(3[01]|[12][0-9]|0?[1-9])
|
  # d/m or dd/mm
  (3[01]|[12][0-9]|0?[1-9])/(1[0-2]|0?[1-9])
)
# /yy or /yyyy
/(?:[0-9]{2})?[0-9]{2}$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])|(3[01]|[12][0-9]|0[1-9])/(1[0-2]|0[1-9]))/[0-9]{4}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:
  # mm/dd
  (1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])
|
  # dd/mm
  (3[01]|[12][0-9]|0[1-9])/(1[0-2]|0[1-9])
)
# /yyyy
/[0-9]{4}$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>\b(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])/[0-9]{4}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.5. Validate Traditional Date Formats, Excluding Invalid Dates</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>^(?&lt;month&gt;[0-3]?[0-9])/(?&lt;day&gt;[0-3]?[0-9])/(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10</p>
<pre>DateTime foundDate;
Match matchResult = Regex.Match(SubjectString,
    "^(?&lt;month&gt;[0-3]?[0-9])/(?&lt;day&gt;[0-3]?[0-9])/" +
    "(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$");
if (matchResult.Success) {
    int year = int.Parse(matchResult.Groups["year"].Value);
    if (year &lt; 50) year += 2000;
    else if (year &lt; 100) year += 1900;
    try {
        foundDate = new DateTime(year,
            int.Parse(matchResult.Groups["month"].Value),
            int.Parse(matchResult.Groups["day"].Value));
    } catch {
        // Invalid date
    }
}</pre>
<pre>^(?&lt;day&gt;[0-3]?[0-9])/(?&lt;month&gt;[0-3]?[0-9])/(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10</p>
<pre>DateTime foundDate;
Match matchResult = Regex.Match(SubjectString,
    "^(?&lt;day&gt;[0-3]?[0-9])/(?&lt;month&gt;[0-3]?[0-9])/" +
    "(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$");
if (matchResult.Success) {
    int year = int.Parse(matchResult.Groups["year"].Value);
    if (year &lt; 50) year += 2000;
    else if (year &lt; 100) year += 1900;
    try {
        foundDate = new DateTime(year,
            int.Parse(matchResult.Groups["month"].Value),
            int.Parse(matchResult.Groups["day"].Value));
    } catch {
        // Invalid date
    }
}</pre>
<h4>Perl</h4>
<pre>^([0-3]?[0-9])/([0-3]?[0-9])/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>@daysinmonth = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
$validdate = 0;
if ($subject =~ m!^([0-3]?[0-9])/([0-3]?[0-9])/((?:[0-9]{2})?[0-9]{2})$!) 
{
    $month = $1;
    $day = $2;
    $year = $3;
    $year += 2000 if $year &lt; 50;
    $year += 1900 if $year &lt; 100;
    if ($month == 2 &amp;&amp; $year % 4 == 0 &amp;&amp; ($year % 100 != 0 ||
                                          $year % 400 == 0)) {
    	$validdate = 1 if $day &gt;= 1 &amp;&amp; $day &lt;= 29;
    } elsif ($month &gt;= 1 &amp;&amp; $month &lt;= 12) {
        $validdate = 1 if $day &gt;= 1 &amp;&amp; $day &lt;= $daysinmonth[$month-1];
    }
}</pre>
<pre>@daysinmonth = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
$validdate = 0;
if ($subject =~ m!^([0-3]?[0-9])/([0-3]?[0-9])/((?:[0-9]{2})?[0-9]{2})$!) 
{
    $day = $1;
    $month = $2;
    $year = $3;
    $year += 2000 if $year &lt; 50;
    $year += 1900 if $year &lt; 100;
    if ($month == 2 &amp;&amp; $year % 4 == 0 &amp;&amp; ($year % 100 != 0 ||
                                          $year % 400 == 0)) {
    	$validdate = 1 if $day &gt;= 1 &amp;&amp; $day &lt;= 29;
    } elsif ($month &gt;= 1 &amp;&amp; $month &lt;= 12) {
        $validdate = 1 if $day &gt;= 1 &amp;&amp; $day &lt;= $daysinmonth[$month-1];
    }
}</pre>
<h4>Pure regular expression</h4>
<pre>^(?:
  # February (29 days every year)
  (?&lt;month&gt;0?2)/(?&lt;day&gt;[12][0-9]|0?[1-9])
|
  # 30-day months
  (?&lt;month&gt;0?[469]|11)/(?&lt;day&gt;30|[12][0-9]|0?[1-9])
|
  # 31-day months
  (?&lt;month&gt;0?[13578]|1[02])/(?&lt;day&gt;3[01]|[12][0-9]|0?[1-9])
)
# Year
/(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Perl 5.10, Ruby 1.9</p>
<pre>^(?:
  # February (29 days every year)
  (0?2)/([12][0-9]|0?[1-9])
|
  # 30-day months
  (0?[469]|11)/(30|[12][0-9]|0?[1-9])
|
  # 31-day months
  (0?[13578]|1[02])/(3[01]|[12][0-9]|0?[1-9])
)
# Year
/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(0?2)/([12][0-9]|0?[1-9])|(0?[469]|11)/(30|[12][0-9]|0?[1-9])|(0?[13578]|1[02])/(3[01]|[12][0-9]|0?[1-9]))/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:
  # February (29 days every year)
  (?&lt;day&gt;[12][0-9]|0?[1-9])/(?&lt;month&gt;0?2)
|
  # 30-day months
  (?&lt;day&gt;30|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[469]|11)
|
  # 31-day months
  (?&lt;day&gt;3[01]|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[13578]|1[02])
)
# Year
/(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Perl 5.10, Ruby 1.9</p>
<pre>^(?:
  # February (29 days every year)
  ([12][0-9]|0?[1-9])/(0?2)
|
  # 30-day months
  (30|[12][0-9]|0?[1-9])/([469]|11)
|
  # 31-day months
  (3[01]|[12][0-9]|0?[1-9])/(0?[13578]|1[02])
)
# Year
/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:([12][0-9]|0?[1-9])/(0?2)|(30|[12][0-9]|0?[1-9])/([469]|11)|(3[01]|[12][0-9]|0?[1-9])/(0?[13578]|1[02]))/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre># 2 May 2007 till 29 August 2008
^(?:
  # 2 May 2007 till 31 December 2007
  (?:
    # 2 May till 31 May
    (?&lt;day&gt;3[01]|[12][0-9]|0?[2-9])/(?&lt;month&gt;0?5)/(?&lt;year&gt;2007)
  |
    # 1 June till 31 December
    (?:
      # 30-day months
      (?&lt;day&gt;30|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[69]|11)
    |
      # 31-day months
      (?&lt;day&gt;3[01]|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[78]|1[02])
    )
    /(?&lt;year&gt;2007)
  )
|
  # 1 January 2008 till 29 August 2008
  (?:
    # 1 August till 29 August
    (?&lt;day&gt;[12][0-9]|0?[1-9])/(?&lt;month&gt;0?8)/(?&lt;year&gt;2008)
  |
    # 1 Janary till 30 June
    (?:
      # February
      (?&lt;day&gt;[12][0-9]|0?[1-9])/(?&lt;month&gt;0?2)
    |
      # 30-day months
      (?&lt;day&gt;30|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[46])
    |
      # 31-day months
      (?&lt;day&gt;3[01]|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[1357])
    )
    /(?&lt;year&gt;2008)
  )
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Perl 5.10, Ruby 1.9</p>
<h2>4.6. Validate Traditional Time Formats</h2>
<h3>Solution</h3>
<pre>^(1[0-2]|0?[1-9]):([0-5]?[0-9])( ?[AP]M)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-2]|0?[1-9]):([0-5]?[0-9]):([0-5]?[0-9])( ?[AP]M)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>\b(2[0-3]|[01]?[0-9]):([0-5]?[0-9])\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?&lt;![:\w])(2[0-3]|[01]?[0-9]):([0-5]?[0-9])(?![:\w])</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby 1.9</p>
<h2>4.7. Validate ISO 8601 Dates and Times</h2>
<h3>Solution</h3>
<h4>Dates</h4>
<pre>^([0-9]{4})-(1[0-2]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;1[0-2]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;year&gt;[0-9]{4})-(?P&lt;month&gt;1[0-2]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Python</p>
<pre>^([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?(?&lt;month&gt;1[0-2]|0[1-9])-?(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^([0-9]{4})(-?)(1[0-2]|0[1-9])\2(3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})(?&lt;hyphen&gt;-?)(?&lt;month&gt;1[0-2]|0[1-9])\k&lt;hyphen&gt;(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;year&gt;[0-9]{4})(?P&lt;hyphen&gt;-?)(?P&lt;month&gt;1[0-2]|0[1-9])(?P=hyphen)(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^([0-9]{4})-?(36[0-6]|3[0-5][0-9]|[12][0-9]{2}|0[1-9][0-9]|00[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?(?&lt;day&gt;36[0-6]|3[0-5][0-9]|[12][0-9]{2}|0[1-9][0-9]|00[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h4>Weeks</h4>
<pre>^([0-9]{4})-?W(5[0-3]|[1-4][0-9]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?W(?&lt;week&gt;5[0-3]|[1-4][0-9]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^([0-9]{4})-?W(5[0-3]|[1-4][0-9]|0[1-9])-?([1-7])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?W(?&lt;week&gt;5[0-3]|[1-4][0-9]|0[1-9])-?(?&lt;day&gt;[1-7])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h4>Times</h4>
<pre>^(2[0-3]|[01][0-9]):?([0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;hour&gt;2[0-3]|[01][0-9]):?(?&lt;minute&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;hour&gt;2[0-3]|[01][0-9]):?(?&lt;minute&gt;[0-5][0-9]):?(?&lt;second&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;hour&gt;2[0-3]|[01][0-9]):?(?&lt;minute&gt;[0-5][0-9]):?(?&lt;second&gt;[0-5][0-9])(?&lt;timezone&gt;Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h4>Date and time</h4>
<pre>^([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9]) (2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?(?&lt;month&gt;1[0-2]|0[1-9])-?(?&lt;day&gt;3[01]|0[1-9]|[12][0-9]) (?&lt;hour&gt;2[0-3]|[01][0-9]):?(?&lt;minute&gt;[0-5][0-9]):?(?&lt;second&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^([0-9]{4})(-)?(1[0-2]|0[1-9])(?(2)-)(3[01]|0[1-9]|[12][0-9]) (2[0-3]|[01][0-9])(?(2):)([0-5][0-9])(?(2):)([0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE, Perl, Python</p>
<pre>^(?&lt;year&gt;[0-9]{4})(?&lt;hyphen&gt;-)?(?&lt;month&gt;1[0-2]|0[1-9])(?(hyphen)-)(?&lt;day&gt;3[01]|0[1-9]|[12][0-9]) (?&lt;hour&gt;2[0-3]|[01][0-9])(?(hyphen):)(?&lt;minute&gt;[0-5][0-9])(?(hyphen):)(?&lt;second&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE 7, Perl 5.10</p>
<pre>^(?P&lt;year&gt;[0-9]{4})(?P&lt;hyphen&gt;-)?(?P&lt;month&gt;1[0-2]|0[1-9])(?(hyphen)-)(?P&lt;day&gt;3[01]|0[1-9]|[12][0-9]) (?P&lt;hour&gt;2[0-3]|[01][0-9])(?(hyphen):)(?P&lt;minute&gt;[0-5][0-9])(?(hyphen):)(?P&lt;second&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Perl 5.10, Python</p>
<pre>^(?:([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9]) (2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])|([0-9]{4})(1[0-2]|0[1-9])(3[01]|0[1-9]|[12][0-9]) (2[0-3]|[01][0-9])([0-5][0-9])([0-5][0-9]))$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>XML Schema dates and times</h4>
<pre>^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;-?(?:[1-9][0-9]*)?[0-9]{4})-(?&lt;month&gt;1[0-2]|0[1-9])-(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])(?&lt;timezone&gt;Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;hour&gt;2[0-3]|[01][0-9]):(?&lt;minute&gt;[0-5][0-9]):(?&lt;second&gt;[0-5][0-9])(?&lt;frac&gt;\.[0-9]+)?(?&lt;timezone&gt;Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;-?(?:[1-9][0-9]*)?[0-9]{4})-(?&lt;month&gt;1[0-2]|0[1-9])-(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])T(?&lt;hour&gt;2[0-3]|[01][0-9]):(?&lt;minute&gt;[0-5][0-9]):(?&lt;second&gt;[0-5][0-9])(?&lt;ms&gt;\.[0-9]+)?(?&lt;timezone&gt;Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h2>4.8. Limit Input to Alphanumeric Characters</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^[A-Z0-9]+$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Ruby example</h4>
<pre>if subject =~ /^[A-Z0-9]+$/i
    puts "Subject is alphanumeric"
else
    puts "Subject is not alphanumeric"
end</pre>
<h3>Discussion</h3>
<pre>^         # Assert position at the beginning of the string.
[A-Z0-9]  # Match a character from A to Z or from 0 to 9
  +       #   between one and unlimited times.
$         # Assert position at the end of the string.</pre>
<p>Regex options: Case
        insensitive, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Limit input to ASCII characters</h4>
<pre>^[\x00-\x7F]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Limit input to ASCII noncontrol characters and line
        breaks</h4>
<pre>^[\n\r\x20-\x7E]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Limit input to shared ISO-8859-1 and Windows-1252
        characters</h4>
<pre>^[\x00-\x7F\xA0-\xFF]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Limit input to alphanumeric characters in any language</h4>
<pre>^[\p{L}\p{M}\p{Nd}]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<pre>^[^\W_]+$</pre>
<p>Regex options: Unicode<br>
Regex flavors: Python</p>
<h2>4.9. Limit the Length of Text</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^[A-Z]{1,10}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Perl example</h4>
<pre>if ($ARGV[0] =~ /^[A-Z]{1,10}$/) {
    print "Input is valid\n";
} else {
    print "Input is invalid\n";
}</pre>
<h3>Discussion</h3>
<pre>^         # Assert position at the beginning of the string.
[A-Z]     # Match one letter from A to Z
  {1,10}  #   between 1 and 10 times.
$         # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Limit the length of an arbitrary pattern</h4>
<pre>^(?=.{1,10}$).*</pre>
<p>Regex options: Dot
          matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?=[\S\s]{1,10}$)[\S\s]*</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Limit the number of nonwhitespace characters</h4>
<pre>^\s*(?:\S\s*){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[\p{Z}\s]*(?:[^\p{Z}\s][\p{Z}\s]*){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<h4>Limit the number of words</h4>
<pre>^\W*(?:\w+\b\W*){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[^\p{L}\p{M}\p{Nd}\p{Pc}]*(?:[\p{L}\p{M}\p{Nd}\p{Pc}]+\b[^\p{L}\p{M}\p{Nd}\p{Pc}]*){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, Perl</p>
<pre>^[^\p{L}\p{M}\p{Nd}\p{Pc}]*(?:[\p{L}\p{M}\p{Nd}\p{Pc}]+(?:[^\p{L}\p{M}\p{Nd}\p{Pc}]+|$)){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<pre>^\s*(?:\S+(?:\s+|$)){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Perl, PCRE, Python, Ruby</p>
<h2>4.10. Limit the Number of Lines in Text</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>\A(?&gt;[^\r\n]*(?&gt;\r\n?|\n)){0,4}[^\r\n]*\z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby</p>
<pre>\A(?:[^\r\n]*(?:\r\n?|\n)){0,4}[^\r\n]*\Z</pre>
<p>Regex options: None<br>
</p><pre>^(?:[^\r\n]*(?:\r\n?|\n)){0,4}[^\r\n]*$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
</p><h4>PHP (PCRE) example</h4>
<pre>if (preg_match('/\A(?&gt;[^\r\n]*(?&gt;\r\n?|\n)){0,4}[^\r\n]*\z/', 
               $_POST['subject'])) {
    print 'Subject contains five or fewer lines';
} else {
    print 'Subject contains more than five lines';
}</pre>
<h3>Discussion</h3>
<pre>\A          # Assert position at the beginning of the string.
(?&gt;         # Group but don't capture or keep backtracking positions:
  [^\r\n]*  #   Match zero or more characters except CR and LF.
  (?&gt;       #   Group but don't capture or keep backtracking positions:
    \r\n?   #     Match a CR, with an optional following LF (CRLF).
   |        #    Or:
    \n      #     Match a standalone LF character.
  )         #   End the noncapturing, atomic group.
){0,4}      # End group; repeat between zero and four times.
[^\r\n]*    # Match zero or more characters except CR and LF.
\z          # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Ruby</p>
<h3>Variations</h3>
<h4>Working with esoteric line separators</h4>
<pre>\A(?&gt;\V*\R){0,4}\V*\z</pre>
<p>Regex options: None<br>
</p><pre>\A(?&gt;[^\n-\r\x85\x{2028}\x{2029}]*(?&gt;\r\n?|[\n-\f\x85\x{2028}\x{2029}])){0,4}[^\n-\r\x85\x{2028}\x{2029}]*\z</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<pre>\A(?&gt;[^\n-\r\u0085\u2028\u2029]*(?&gt;\r\n?|[\n-\f\u0085\u2028\u2029])){0,4}[^\n-\r\u0085\u2028\u2029]*\z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, Ruby 1.9</p>
<pre>\A(?&gt;[^\n-\r\x85\u2028\u2029]*(?&gt;\r\n?|[\n-\f\x85\u2028\u2029])){0,4}[^\n-\r\x85\u2028\u2029]*\z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java</p>
<pre>\A(?:[^\n-\r\x85\u2028\u2029]*(?:\r\n?|[\n-\f\x85\u2028\u2029])){0,4}[^\n-\r\x85\u2028\u2029]*\Z</pre>
<p>Regex options: None<br>
</p><pre>^(?:[^\n-\r\x85\u2028\u2029]*(?:\r\n?|[\n-\f\x85\u2028\u2029])){0,4}[^\n-\r\x85\u2028\u2029]*$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
</p><h2>4.11. Validate Affirmative Responses</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(?:1|t(?:rue)?|y(?:es)?|ok(?:ay)?)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>JavaScript example</h4>
<pre>var yes = /^(?:1|t(?:rue)?|y(?:es)?|ok(?:ay)?)$/i;

if (yes.test(subject)) {
    alert("Yes");
} else {
    alert("No");
}</pre>
<h3>Discussion</h3>
<pre>^            # Assert position at the beginning of the string.
(?:          # Group but don't capture:
  1          #   Match "1".
 |           #  Or:
  t(?:rue)?  #   Match "t", optionally followed by "rue".
 |           #  Or:
  y(?:es)?   #   Match "y", optionally followed by "es".
 |           #  Or:
  ok(?:ay)?  #   Match "ok", optionally followed by "ay".
)            # End the noncapturing group.
$            # Assert position at the end of the string.</pre>
<p>Regex options: Case
        insensitive, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>4.12. Validate Social Security Numbers</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-(?!0000)[0-9]{4}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Python example</h4>
<pre>if re.match(r"^(?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-(?!0000)[0-9]{4}$", sys.argv[1]):
    print "SSN is valid"
else:
    print "SSN is invalid"</pre>
<h3>Discussion</h3>
<pre>^            # Assert position at the beginning of the string.
(?!000|666)  # Assert that neither "000" nor "666" can be matched here.
[0-8]        # Match a digit between 0 and 8.
[0-9]{2}     # Match a digit, exactly two times.
-            # Match a literal "-".
(?!00)       # Assert that "00" cannot be matched here.
[0-9]{2}     # Match a digit, exactly two times.
-            # Match a literal "-".
(?!0000)     # Assert that "0000" cannot be matched here.
[0-9]{4}     # Match a digit, exactly four times.
$            # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Find Social Security numbers in documents</h4>
<pre>\b(?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-(?!0000)[0-9]{4}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.13. Validate ISBNs</h2>
<h3>Solution</h3>
<h4>Regular expressions</h4>
<pre>^(?:ISBN(?:-10)?:? )?(?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$)[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^
(?:ISBN(?:-10)?:?\ )?     # Optional ISBN/ISBN-10 identifier.
(?=                       # Basic format pre-checks (lookahead):
  [0-9X]{10}$             #   Require 10 digits/Xs (no separators).
 |                        #  Or:
  (?=(?:[0-9]+[-\ ]){3})  #   Require 3 separators
  [-\ 0-9X]{13}$          #     out of 13 characters total.
)                         # End format pre-checks.
[0-9]{1,5}[-\ ]?          # 1-5 digit group identifier.
[0-9]+[-\ ]?[0-9]+[-\ ]?  # Publisher and title identifiers.
[0-9X]                    # Check digit.
$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:ISBN(?:-13)?:? )?(?=[0-9]{13}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)97[89][- ]?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^
(?:ISBN(?:-13)?:?\ )?     # Optional ISBN/ISBN-13 identifier.
(?=                       # Basic format pre-checks (lookahead):
  [0-9]{13}$              #   Require 13 digits (no separators).
 |                        #  Or:
  (?=(?:[0-9]+[-\ ]){4})  #   Require 4 separators
  [-\ 0-9]{17}$           #     out of 17 characters total.
)                         # End format pre-checks.
97[89][-\ ]?              # ISBN-13 prefix.
[0-9]{1,5}[-\ ]?          # 1-5 digit group identifier.
[0-9]+[-\ ]?[0-9]+[-\ ]?  # Publisher and title identifiers.
[0-9]                     # Check digit.
$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:ISBN(?:-1[03])?:? )?(?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^
(?:ISBN(?:-1[03])?:?\ )?  # Optional ISBN/ISBN-10/ISBN-13 identifier.
(?=                       # Basic format pre-checks (lookahead):
  [0-9X]{10}$             #   Require 10 digits/Xs (no separators).
 |                        #  Or:
  (?=(?:[0-9]+[-\ ]){3})  #   Require 3 separators
  [-\ 0-9X]{13}$          #     out of 13 characters total.
 |                        #  Or:
  97[89][0-9]{10}$        #   978/979 plus 10 digits (13 total).
 |                        #  Or:
  (?=(?:[0-9]+[-\ ]){4})  #   Require 4 separators
  [-\ 0-9]{17}$           #     out of 17 characters total.
)                         # End format pre-checks.
(?:97[89][-\ ]?)?         # Optional ISBN-13 prefix.
[0-9]{1,5}[-\ ]?          # 1-5 digit group identifier.
[0-9]+[-\ ]?[0-9]+[-\ ]?  # Publisher and title identifiers.
[0-9X]                    # Check digit.
$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>JavaScript example, with checksum validation</h4>
<pre>var subject = document.getElementById("isbn").value;

// Checks for ISBN-10 or ISBN-13 format
var regex = /^(?:ISBN(?:-1[03])?:? )?(?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$/;

if (regex.test(subject)) {
    // Remove non ISBN digits, then split into an array
    var chars = subject.replace(/[- ]|^ISBN(?:-1[03])?:?/g, "").split("");
    // Remove the final ISBN digit from `chars`, and assign it to `last`
    var last = chars.pop();
    var sum = 0;
    var check, i;

    if (chars.length == 9) {
        // Compute the ISBN-10 check digit
        chars.reverse();
        for (i = 0; i &lt; chars.length; i++) {
            sum += (i + 2) * parseInt(chars[i], 10);
        }
        check = 11 - (sum % 11);
        if (check == 10) {
            check = "X";
        } else if (check == 11) {
            check = "0";
        }
    } else {
        // Compute the ISBN-13 check digit
        for (i = 0; i &lt; chars.length; i++) {
            sum += (i % 2 * 2 + 1) * parseInt(chars[i], 10);
        }
        check = 10 - (sum % 10);
        if (check == 10) {
            check = "0";
        }
    }

    if (check == last) {
        alert("Valid ISBN");
    } else {
        alert("Invalid ISBN check digit");
    }
} else {
    alert("Invalid ISBN");
}</pre>
<h4>Python example, with checksum validation</h4>
<pre>import re
import sys

subject = sys.argv[1]

# Checks for ISBN-10 or ISBN-13 format
regex = re.compile("^(?:ISBN(?:-1[03])?:? )?(?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$")

if regex.search(subject):
    # Remove non ISBN digits, then split into a list
    chars = list(re.sub("[- ]|^ISBN(?:-1[03])?:?", "", subject))
    # Remove the final ISBN digit from `chars`, and assign it to `last`
    last = chars.pop()

    if len(chars) == 9:
        # Compute the ISBN-10 check digit
        val = sum((x + 2) * int(y) for x,y in enumerate(reversed(chars)))
        check = 11 - (val % 11)
        if check == 10:
            check = "X"
        elif check == 11:
            check = "0"
    else:
        # Compute the ISBN-13 check digit
        val = sum((x % 2 * 2 + 1) * int(y) for x,y in enumerate(chars))
        check = 10 - (val % 10)
        if check == 10:
            check = "0"

    if (str(check) == last):
        print("Valid ISBN")
    else:
        print("Invalid ISBN check digit")
else:
    print("Invalid ISBN")</pre>
<h3>Discussion</h3>
<h4>ISBN-10 checksum</h4>
<pre>Step 1:
sum = 10×0 + 9×5 + 8×9 + 7×6 + 6×5 + 5×2 + 4×0 + 3×6 + 2×8
    =    0 +  45 +  72 +  42 +  30 +  10 +   0 +  18 +  16
    = 233
Step 2:
    233 ÷ 11 = 21, remainder 2
Step 3:
    11 − 2 = 9
Step 4:
    9 [no substitution required]</pre>
<h4>ISBN-13 checksum</h4>
<pre>Step 1:
sum = 1×9 + 3×7 + 1×8 + 3×0 + 1×5 + 3×9 + 1×6 + 3×5 + 1×2 + 3×0 + 1×6 + 3×8
    =   9 +  21 +   8 +   0 +   5 +  27 +   6 +  15 +   2 +   0 +   6 +  24
    = 123
Step 2:
    123 ÷ 10 = 12, remainder 3
Step 3:
    10 − 3 = 7
Step 4:
    7 [no substitution required]</pre>
<h3>Variations</h3>
<h4>Find ISBNs in documents</h4>
<pre>\bISBN(?:-1[03])?:? (?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Eliminate incorrect ISBN identifiers</h4>
<pre>^
(?:ISBN(-1(?:(0)|3))?:?\ )?
(?(1)
  (?(2)
    # ISBN-10
    (?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$)
    [0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]
   |
    # ISBN-13
    (?=[0-9]{13}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)
    97[89][- ]?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9]
  )
 |
  # No explicit identifier; allow ISBN-10 or ISBN-13
  (?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|
    (?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)
  (?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]
)
$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          PCRE, Perl, Python</p>
<h2>4.14. Validate ZIP Codes</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^[0-9]{5}(?:-[0-9]{4})?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>VB.NET example</h4>
<pre>If Regex.IsMatch(subjectString, "^[0-9]{5}(?:-[0-9]{4})?$") Then
    Console.WriteLine("Valid ZIP code")
Else
    Console.WriteLine("Invalid ZIP code")
End If</pre>
<h3>Discussion</h3>
<pre>^           # Assert position at the beginning of the string.
[0-9]{5}    # Match a digit, exactly five times.
(?:         # Group but don't capture:
  -         #   Match a literal "-".
  [0-9]{4}  #   Match a digit, exactly four times.
)           # End the noncapturing group.
  ?         #   Make the group optional.
$           # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>4.15. Validate Canadian Postal Codes</h2>
<h3>Solution</h3>
<pre>^(?!.*[DFIOQU])[A-VXY][0-9][A-Z] ?[0-9][A-Z][0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.16. Validate U.K. Postcodes</h2>
<h3>Solution</h3>
<pre>^[A-Z]{1,2}[0-9R][0-9A-Z]? [0-9][ABD-HJLNP-UW-Z]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>^(?:(?:[A-PR-UWYZ][0-9]{1,2}|[A-PR-UWYZ][A-HK-Y][0-9]{1,2}|[A-PR-UWYZ][0-9][A-HJKSTUW]|[A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRV-Y]) [0-9][ABD-HJLNP-UW-Z]{2}|GIR 0AA)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.17. Find Addresses with Post Office Boxes</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(?:Post(?:al)? (?:Office )?|P[. ]?O\.? )?Box\b</pre>
<p>Regex options: Case
          insensitive, ^ and $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>C# example</h4>
<pre>Regex regexObj = new Regex(
    @"^(?:Post(?:al)? (?:Office )?|P[. ]?O\.? )?Box\b",
    RegexOptions.IgnoreCase | RegexOptions.Multiline
);
if (regexObj.IsMatch(subjectString) {
    Console.WriteLine("The value does not appear to be a street address");
} else {
    Console.WriteLine("Good to go");
}</pre>
<h3>Discussion</h3>
<pre>^                # Assert position at the beginning of a line.
(?:              # Group but don't capture:
  Post(?:al)?\   #   Match "Post " or "Postal ".
  (?:Office\ )?  #   Optionally match "Office ".
 |               #  Or:
  P[.\ ]?        #   Match "P" and an optional period or space character.
  O\.?\          #   Match "O", an optional period, and a space character.
)?               # Make the group optional.
Box              # Match "Box".
\b               # Assert position at a word boundary.</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>4.18. Reformat Names From “FirstName LastName” to “LastName,
    FirstName”</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(.+?) ([^\s,]+)(,? (?:[JS]r\.?|III?|IV))?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>$2, $1$3</pre>
<pre>\2, \1\3</pre>
<h4>JavaScript example</h4>
<pre>function formatName(name) {
    return name.replace(/^(.+?) ([^\s,]+)(,? (?:[JS]r\.?|III?|IV))?$/i,
                        "$2, $1$3");
}</pre>
<h3>Discussion</h3>
<pre>^              # Assert position at the beginning of the string.
(              # Capture the enclosed match to backreference 1:
  .+?          #   Match one or more characters, as few times as possible.
)              # End the capturing group.
\              # Match a literal space character.
(              # Capture the enclosed match to backreference 2:
  [^\s,]+      #   Match one or more non-whitespace/comma characters.
)              # End the capturing group.
(              # Capture the enclosed match to backreference 3:
  ,?\          #   Match ", " or " ".
  (?:          #   Group but don't capture:
    [JS]r\.?   #     Match "Jr", "Jr.", "Sr", or "Sr.".
   |           #    Or:
    III?       #     Match "II" or "III".
   |           #    Or:
    IV         #     Match "IV".
  )            #   End the noncapturing group.
)?             # Make the group optional.
$              # Assert position at the end of the string.</pre>
<p>Regex options: Case
        insensitive, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>List surname particles at the beginning of the name</h4>
<pre>^(.+?) ((?:(?:d[eu]|l[ae]|Ste?\.?|v[ao]n) )*[^\s,]+)(,? (?:[JS]r\.?|III?|IV))?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>$2, $1$3</pre>
<pre>\2, \1\3</pre>
<h2>4.19. Validate Password Complexity</h2>
<h3>Solution</h3>
<h4>Length between 8 and 32 characters</h4>
<pre>^.{8,32}$</pre>
<p>Regex options: Dot
          matches line breaks (“^ and $ match at line breaks” must not be
          set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^[\s\S]{8,32}$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>ASCII visible and space characters only</h4>
<pre>^[\x20-\x7E]+$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>One or more uppercase letters</h4>
<pre>[A-Z]</pre>
<p>Regex options: None
          (“case insensitive” must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\p{Lu}</pre>
<p>Regex options: None
          (“case insensitive” must not be set)<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby 1.9</p>
<h4>One or more lowercase letters</h4>
<pre>[a-z]</pre>
<p>Regex options: None
          (“case insensitive” must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\p{Ll}</pre>
<p>Regex options: None
          (“case insensitive” must not be set)<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby 1.9</p>
<h4>One or more numbers</h4>
<pre>[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>One or more special characters</h4>
<pre>[ !"#$%&amp;'()*+,\-./:;&lt;=&gt;?@[\\\]^_`{|}~]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>[^A-Za-z0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Disallow three or more sequential identical characters</h4>
<pre>(.)\1\1</pre>
<p>Regex options: Dot
          matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>([\s\S])\1\1</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Example JavaScript solution, basic</h4>
<pre>function validate(password) {
    var minMaxLength = /^[\s\S]{8,32}$/,
        upper = /[A-Z]/,
        lower = /[a-z]/,
        number = /[0-9]/,
        special = /[ !"#$%&amp;'()*+,\-./:;&lt;=&gt;?@[\\\]^_`{|}~]/;

    if (minMaxLength.test(password) &amp;&amp;
        upper.test(password) &amp;&amp;
        lower.test(password) &amp;&amp;
        number.test(password) &amp;&amp;
        special.test(password)
    ) {
        return true;
    }

    return false;
}</pre>
<h4>Example JavaScript solution, with x out of y validation</h4>
<pre>function validate(password) {
    var minMaxLength = /^[\s\S]{8,32}$/,
        upper = /[A-Z]/,
        lower = /[a-z]/,
        number = /[0-9]/,
        special = /[^A-Za-z0-9]/,
        count = 0;

    if (minMaxLength.test(password)) {
        // Only need 3 out of 4 of these to match
        if (upper.test(password)) count++;
        if (lower.test(password)) count++;
        if (number.test(password)) count++;
        if (special.test(password)) count++;
    }

    return count &gt;= 3;
}</pre>
<h4>Example JavaScript solution, with password security
        ranking</h4>
<pre>var rank = {
    TOO_SHORT: 0,
    WEAK: 1,
    MEDIUM: 2,
    STRONG: 3,
    VERY_STRONG: 4
};

function rankPassword(password) {
    var upper = /[A-Z]/,
        lower = /[a-z]/,
        number = /[0-9]/,
        special = /[^A-Za-z0-9]/,
        minLength = 8,
        score = 0;

    if (password.length &lt; minLength) {
        return rank.TOO_SHORT; // End early
    }

    // Increment the score for each of these conditions
    if (upper.test(password)) score++;
    if (lower.test(password)) score++;
    if (number.test(password)) score++;
    if (special.test(password)) score++;

    // Penalize if there aren't at least three char types
    if (score &lt; 3) score--;

    if (password.length &gt; minLength) {
        // Increment the score for every 2 chars longer than the minimum
        score += Math.floor((password.length - minLength) / 2);
    }

    // Return a ranking based on the calculated score
    if (score &lt; 3) return rank.WEAK; // score is 2 or lower
    if (score &lt; 4) return rank.MEDIUM; // score is 3
    if (score &lt; 6) return rank.STRONG; // score is 4 or 5
    return rank.VERY_STRONG; // score is 6 or higher
}

// Test it...
var result = rankPassword("password1"),
    labels = ["Too Short", "Weak", "Medium", "Strong", "Very Strong"];

alert(labels[result]); // -&gt; Weak</pre>
<h3>Variations</h3>
<h4>Validate multiple password rules with a single regex</h4>
<pre>^(?=.{8,32}$)(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9]).*</pre>
<p>Regex options: Dot
          matches line breaks (“^ and $ match at line breaks” must not be
          set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>4.20. Validate Credit Card Numbers</h2>
<h3>Solution</h3>
<h4>Strip spaces and hyphens</h4>
<pre>[ -]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Validate the number</h4>
<pre>^(?:
(?&lt;visa&gt;4[0-9]{12}(?:[0-9]{3})?) |
(?&lt;mastercard&gt;5[1-5][0-9]{14}) |
(?&lt;discover&gt;6(?:011|5[0-9]{2})[0-9]{12}) |
(?&lt;amex&gt;3[47][0-9]{13}) |
(?&lt;diners&gt;3(?:0[0-5]|[68][0-9])[0-9]{11}) |
(?&lt;jcb&gt;(?:2131|1800|35[0-9]{3})[0-9]{11})
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?:
(?P&lt;visa&gt;4[0-9]{12}(?:[0-9]{3})?) |
(?P&lt;mastercard&gt;5[1-5][0-9]{14}) |
(?P&lt;discover&gt;6(?:011|5[0-9]{2})[0-9]{12}) |
(?P&lt;amex&gt;3[47][0-9]{13}) |
(?P&lt;diners&gt;3(?:0[0-5]|[68][0-9])[0-9]{11}) |
(?P&lt;jcb&gt;(?:2131|1800|35[0-9]{3})[0-9]{11})
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: PCRE,
          Python</p>
<pre>^(?:
(4[0-9]{12}(?:[0-9]{3})?) |          # Visa
(5[1-5][0-9]{14}) |                  # MasterCard
(6(?:011|5[0-9]{2})[0-9]{12}) |      # Discover
(3[47][0-9]{13}) |                   # AMEX
(3(?:0[0-5]|[68][0-9])[0-9]{11}) |   # Diners Club
((?:2131|1800|35[0-9]{3})[0-9]{11})  # JCB
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Example web page with JavaScript</h4>
<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Credit Card Test&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h1&gt;Credit Card Test&lt;/h1&gt;

&lt;form&gt;
&lt;p&gt;Please enter your credit card number:&lt;/p&gt;

&lt;p&gt;&lt;input type="text" size="20" name="cardnumber"
  onkeyup="validatecardnumber(this.value)"&gt;&lt;/p&gt;

&lt;p id="notice"&gt;(no card number entered)&lt;/p&gt;
&lt;/form&gt;

&lt;script&gt;
function validatecardnumber(cardnumber) {
  // Strip spaces and dashes
  cardnumber = cardnumber.replace(/[ -]/g, '');
  // See if the card is valid
  // The regex will capture the number in one of the capturing groups
  var match = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/.exec(cardnumber);
  if (match) {
    // List of card types, in the same order as the regex capturing groups
    var types = ['Visa', 'MasterCard', 'Discover', 'American Express',
                 'Diners Club', 'JCB'];
    // Find the capturing group that matched
    // Skip the zeroth element of the match array (the overall match)
    for (var i = 1; i &lt; match.length; i++) {
      if (match[i]) {
        // Display the card type for that group
        document.getElementById('notice').innerHTML = types[i - 1];
        break;
      }
    }
  } else {
    document.getElementById('notice').innerHTML = '(invalid card number)';
  }
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h3>Discussion</h3>
<h4>Validate the number</h4>
<pre>^(?:
4[0-9]{12}(?:[0-9]{3})? |         # Visa
5[1-5][0-9]{14} |                 # MasterCard
3[47][0-9]{13}                    # AMEX
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Extra Validation with the Luhn Algorithm</h3>
<pre>function luhn(cardnumber) {
  // Build an array with the digits in the card number
  var digits = cardnumber.split('');
  for (var i = 0; i &lt; digits.length; i++) {
    digits[i] = parseInt(digits[i], 10);
  }  
  // Run the Luhn algorithm on the array
  var sum = 0;
  var alt = false;
  for (i = digits.length - 1; i &gt;= 0; i--) {
    if (alt) {
      digits[i] *= 2;
      if (digits[i] &gt; 9) {
        digits[i] -= 9;
      }
    }
    sum += digits[i];
    alt = !alt;
  }
  // Check the result
  if (sum % 10 == 0) {
    document.getElementById('notice').innerHTML += '; Luhn check passed';
  } else {
    document.getElementById('notice').innerHTML += '; Luhn check failed';
  }
}</pre>
<h2>4.21. European VAT Numbers</h2>
<h3>Solution</h3>
<h4>Strip whitespace and punctuation</h4>
<pre>[-. ]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Validate the number</h4>
<pre>^(
(AT)?U[0-9]{8} |                              # Austria
(BE)?0[0-9]{9} |                              # Belgium
(BG)?[0-9]{9,10} |                            # Bulgaria
(CY)?[0-9]{8}L |                              # Cyprus
(CZ)?[0-9]{8,10} |                            # Czech Republic
(DE)?[0-9]{9} |                               # Germany
(DK)?[0-9]{8} |                               # Denmark
(EE)?[0-9]{9} |                               # Estonia
(EL|GR)?[0-9]{9} |                            # Greece
(ES)?[0-9A-Z][0-9]{7}[0-9A-Z] |               # Spain
(FI)?[0-9]{8} |                               # Finland
(FR)?[0-9A-Z]{2}[0-9]{9} |                    # France
(GB)?([0-9]{9}([0-9]{3})?|[A-Z]{2}[0-9]{3}) | # United Kingdom
(HU)?[0-9]{8} |                               # Hungary
(IE)?[0-9]S[0-9]{5}L |                        # Ireland
(IT)?[0-9]{11} |                              # Italy
(LT)?([0-9]{9}|[0-9]{12}) |                   # Lithuania
(LU)?[0-9]{8} |                               # Luxembourg
(LV)?[0-9]{11} |                              # Latvia
(MT)?[0-9]{8} |                               # Malta
(NL)?[0-9]{9}B[0-9]{2} |                      # Netherlands
(PL)?[0-9]{10} |                              # Poland
(PT)?[0-9]{9} |                               # Portugal
(RO)?[0-9]{2,10} |                            # Romania
(SE)?[0-9]{12} |                              # Sweden
(SI)?[0-9]{8} |                               # Slovenia
(SK)?[0-9]{10}                                # Slovakia
)$</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^((AT)?U[0-9]{8}|(BE)?0[0-9]{9}|(BG)?[0-9]{9,10}|(CY)?[0-9]{8}L|(CZ)?[0-9]{8,10}|(DE)?[0-9]{9}|(DK)?[0-9]{8}|(EE)?[0-9]{9}|(EL|GR)?[0-9]{9}|(ES)?[0-9A-Z][0-9]{7}[0-9A-Z]|(FI)?[0-9]{8}|(FR)?[0-9A-Z]{2}[0-9]{9}|(GB)?([0-9]{9}([0-9]{3})?|[A-Z]{2}[0-9]{3})|(HU)?[0-9]{8}|(IE)?[0-9]S[0-9]{5}L|(IT)?[0-9]{11}|(LT)?([0-9]{9}|[0-9]{12})|(LU)?[0-9]{8}|(LV)?[0-9]{11}|(MT)?[0-9]{8}|(NL)?[0-9]{9}B[0-9]{2}|(PL)?[0-9]{10}|(PT)?[0-9]{9}|(RO)?[0-9]{2,10}|(SE)?[0-9]{12}|(SI)?[0-9]{8}|(SK)?[0-9]{10})$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h1>5. Words, Lines, and Special Characters</h1>
<h2>5.1. Find a Specific Word</h2>
<h3>Solution</h3>
<pre>\bcat\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>// 8-bit-wide letter characters
var pL = "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\xFF",
    pattern = "([^{L}]|^)cat([^{L}]|$)".replace(/{L}/g, pL),
    regex = new RegExp(pattern, "gi");

// replace cat with dog, and put back any
// additional matched characters
subject = subject.replace(regex, "$1dog$2");</pre>
<h2>5.2. Find Any of Multiple Words</h2>
<h3>Solution</h3>
<h4>Using alternation</h4>
<pre>\b(?:one|two|three)\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Example JavaScript solution</h4>
<pre>var subject = "One times two plus one equals three.";

// Solution 1:

var regex = /\b(?:one|two|three)\b/gi;

subject.match(regex);
// Returns an array with four matches: ["One","two","one","three"]

// Solution 2 (reusable):

// This function does the same thing but accepts an array of words to
// match. Any regex metacharacters within the accepted words are escaped
// with a backslash before searching.

function matchWords(subject, words) {
    var regexMetachars = /[(){[*+?.\\^$|]/g;

    for (var i = 0; i &lt; words.length; i++) {
        words[i] = words[i].replace(regexMetachars, "\\$&amp;");
    }

    var regex = new RegExp("\\b(?:" + words.join("|") + ")\\b", "gi");

    return subject.match(regex) || [];
}

matchWords(subject, ["one","two","three"]);
// Returns an array with four matches: ["One","two","one","three"]</pre>
<h2>5.3. Find Similar Words</h2>
<h3>Solution</h3>
<h4>Color or colour</h4>
<pre>\bcolou?r\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Bat, cat, or rat</h4>
<pre>\b[bcr]at\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Words ending with “phobia”</h4>
<pre>\b\w*phobia\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Steve, Steven, or Stephen</h4>
<pre>\bSte(?:ven?|phen)\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Variations of “regular expression”</h4>
<pre>\breg(?:ular expressions?|ex(?:ps?|e[sn])?)\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<h4>Variations of “regular expression”</h4>
<pre>\b              # Assert position at a word boundary.
reg             # Match "reg".
(?:             # Group but don't capture:
  ular\         #   Match "ular ".
  expressions?  #   Match "expression" or "expressions".
 |              #  Or:
  ex            #   Match "ex".
  (?:           #   Group but don't capture:
    ps?         #     Match "p" or "ps".
   |            #    Or:
    e[sn]       #     Match "es" or "en".
  )?            #   End the group and make it optional.
)               # End the group.
\b              # Assert position at a word boundary.</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>5.4. Find All Except a Specific Word</h2>
<h3>Solution</h3>
<pre>\b(?!cat\b)\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>\b     # Assert position at a word boundary.
(?!    # Not followed by:
  cat  #   Match "cat".
  \b   #   Assert position at a word boundary.
)      # End the negative lookahead.
\w+    # Match one or more word characters.</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Find words that don’t contain another word</h4>
<pre>\b(?:(?!cat)\w)+\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.5. Find Any Word Not Followed by a Specific Word</h2>
<h3>Solution</h3>
<pre>\b\w+\b(?!\W+cat\b)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>\b\w+\b(?=\W+cat\b)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.6. Find Any Word Not Preceded by a Specific Word</h2>
<h3>Solution</h3>
<h4>Words not preceded by “cat”</h4>
<pre>(?&lt;!\bcat\W+)\b\w+</pre>
<p>Regex options: Case
          insensitive<br>
</p><pre>(?&lt;!\bcat\W{1,9})\b\w+</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java</p>
<pre>(?&lt;!\bcat\W)\b\w+</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python</p>
<pre>(?&lt;!\Wcat\W)(?&lt;!^cat\W)\b\w+</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<h4>Simulate lookbehind</h4>
<pre>var subject = "My cat is fluffy.",
    mainRegex = /\b\w+/g,
    lookbehind = /\bcat\W+$/i,
    lookbehindType = false, // false for negative, true for positive
    matches = [],
    match,
    leftContext;

while (match = mainRegex.exec(subject)) {
    leftContext = subject.substring(0, match.index);

    if (lookbehindType == lookbehind.test(leftContext)) {
        matches.push(match[0]);
    } else {
        mainRegex.lastIndex = match.index + 1;
    }
}

// matches:  ["My", "cat", "fluffy"]</pre>
<h3>Variations</h3>
<pre>(?&lt;=\bcat\W+)\w+</pre>
<p>Regex options: Case
        insensitive<br>
</p><pre>(?&lt;=\bcat\W{1,9})\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java</p>
<pre>(?&lt;=\bcat\W)\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python</p>
<pre>(?:(?&lt;=\Wcat\W)|(?&lt;=^cat\W))\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>\bcat\W+\K\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: PCRE
        7.2, Perl 5.10</p>
<h2>5.7. Find Words Near Each Other</h2>
<h3>Solution</h3>
<pre>\b(?:word1\W+(?:\w+\W+){0,5}?word2|word2\W+(?:\w+\W+){0,5}?word1)\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:
  word1                 # first term
  \W+ (?:\w+\W+){0,5}?  # up to five words
  word2                 # second term
|                       #   or, the same pattern in reverse:
  word2                 # second term
  \W+ (?:\w+\W+){0,5}?  # up to five words
  word1                 # first term
)\b</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Using a conditional</h4>
<pre>\b(?:word1|(word2))\W+(?:\w+\W+){0,5}?(?(1)word1|word2)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE, Perl, Python</p>
<pre>\b(?:(?&lt;w1&gt;word1)|(?&lt;w2&gt;word2))\W+(?:\w+\W+){0,5}?(?(w2)(?&amp;w1)|(?&amp;w2))\b</pre>
<p>Regex options: None<br>
Regex flavors: PCRE
          7, Perl 5.10</p>
<h4>Match three or more words near each other</h4>
<pre>\b(?:(?&gt;(word1)|(word2)|(word3)|(?(1)|(?(2)|(?(3)|(?!))))\w+)\b\W*?){3,8}(?(1)(?(2)(?(3)|(?!))|(?!))|(?!))</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, PCRE, Perl</p>
<pre>\b(?:(?:(word1)|(word2)|(word3)|(?(1)|(?(2)|(?(3)|(?!))))\w+)\b\W*?){3,8}(?(1)(?(2)(?(3)|(?!))|(?!))|(?!))</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, PCRE, Perl, Python</p>
<pre>\b(?:(?&gt;word1()|word2()|word3()|(?&gt;\1|\2|\3)\w+)\b\W*?){3,8}\1\2\3</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, Java, PCRE, Perl, Ruby</p>
<pre>\b(?:(?:word1()|word2()|word3()|(?:\1|\2|\3)\w+)\b\W*?){3,8}\1\2\3</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, Java, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:(?&gt;word1()|word2()|word3()|word4()|(?&gt;\1|\2|\3|\4)\w+)\b\W*?){4,9}\1\2\3\4</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, Java, PCRE, Perl, Ruby</p>
<pre>\b(?:(?:word1()|word2()|word3()|word4()|(?:\1|\2|\3|\4)\w+)\b\W*?){4,9}\1\2\3\4</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, Java, PCRE, Perl, Python, Ruby</p>
<h4>Multiple words, any distance from each other</h4>
<pre>^(?=.*?\bword1\b)(?=.*?\bword2\b).*</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks (“^ and $ match at line breaks”
          must not be set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?=[\s\S]*?\bword1\b)(?=[\s\S]*?\bword2\b)[\s\S]*</pre>
<p>Regex options: Case
          insensitive (“^ and $ match at line breaks” must not be
          set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.8. Find Repeated Words</h2>
<h3>Solution</h3>
<pre>\b([A-Z]+)\s+\1\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?&lt;![\p{L}\p{M}\-'\u2019])([\-'\u2019]?(?:[\p{L}\p{M}][\-'\u2019]?)+)\s+\1(?![\p{L}\p{M}\-'\u2019])</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, Ruby 1.9</p>
<pre>(?&lt;![\p{L}\p{M}\-'\x{2019}])([\-'\x{2019}]?(?:[\p{L}\p{M}][\-'\x{2019}]?)+)\s+\1(?![\p{L}\p{M}\-'\x{2019}])</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: Java 7,
        PCRE, Perl</p>
<h2>5.9. Remove Duplicate Lines</h2>
<h3>Solution</h3>
<h4>Option 1: Sort lines and remove adjacent duplicates</h4>
<pre>^(.*)(?:(?:\r?\n|\r)\1)+$</pre>
<p>Regex options: ^ and
          $ match at line breaks (“dot matches line breaks” must not be
          set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>$1</pre>
<pre>\1</pre>
<h4>Option 2: Keep the last occurrence of each duplicate line in an
        unsorted file</h4>
<pre>^([^\r\n]*)(?:\r?\n|\r)(?=.*^\1$)</pre>
<p>Regex options: Dot
          matches line breaks, ^ and $ match at line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(.*)(?:\r?\n|\r)(?=[\s\S]*^\1$)</pre>
<p>Regex options: ^ and
          $ match at line breaks (“dot matches line breaks” must not be
          set)<br>
</p><h4>Option 3: Keep the first occurrence of each duplicate line in
        an unsorted file</h4>
<pre>^([^\r\n]*)$(.*?)(?:(?:\r?\n|\r)\1$)+</pre>
<p>Regex options: Dot
          matches line breaks, ^ and $ match at line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(.*)$([\s\S]*?)(?:(?:\r?\n|\r)\1$)+</pre>
<p>Regex options: ^ and
          $ match at line breaks (“dot matches line breaks” must not be
          set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>$1$2</pre>
<pre>\1\2</pre>
<h3>Discussion</h3>
<h4>Option 3: Keep the first occurrence of each duplicate line in
        an unsorted file</h4>
<pre>value1
value2
value2
value3
value3
value1
value2</pre>
<h2>5.10. Match Complete Lines That Contain a Word</h2>
<h3>Solution</h3>
<pre>^.*\berror\b.*$</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks (“dot matches line breaks”
        must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>^.*\b(one|two|three)\b.*$</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks (“dot matches line breaks”
        must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?=.*?\bone\b)(?=.*?\btwo\b)(?=.*?\bthree\b).+$</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks (“dot matches line breaks”
        must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.11. Match Complete Lines That Do Not Contain a Word</h2>
<h3>Solution</h3>
<pre>^(?:(?!\berror\b).)*$</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks (“dot matches line breaks”
        must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.12. Trim Leading and Trailing Whitespace</h2>
<h3>Solution</h3>
<pre>\A\s+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^\s+</pre>
<p>Regex options: None (“^
        and $ match at line breaks” must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\s+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\s+$</pre>
<p>Regex options: None (“^
        and $ match at line breaks” must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h3>Discussion</h3>
<pre>sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}</pre>
<pre>// Add the trim method for browsers that don't already include it
if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^\s+/, "").replace(/\s+$/, "");
    };
}</pre>
<h2>5.13. Replace Repeated Whitespace with a Single Space</h2>
<h3>Solution</h3>
<h4>Clean any whitespace characters</h4>
<pre>\s+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Clean horizontal whitespace characters</h4>
<pre>[ \t\xA0]+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby 1.8</p>
<pre>[ \t\u00A0]+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>\h+</pre>
<p>Regex options: None<br>
Regex flavors: PCRE
          7.2, Perl 5.10</p>
<h2>5.14. Escape Regular Expression Metacharacters</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>[[\]{}()*+?.\\|^$\-,&amp;#\s]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>\$&amp;</pre>
<pre>\$0</pre>
<pre>\\$&amp;</pre>
<pre>\\$0</pre>
<pre>\\\0</pre>
<pre>\\\&amp;</pre>
<pre>\\\g&lt;0&gt;</pre>
<h4>Example JavaScript function</h4>
<pre>RegExp.escape = function(str) {
    return str.replace(/[[\]{}()*+?.\\|^$\-,&amp;#\s]/g, "\\$&amp;");
};

// Test it...
var str = "&lt;Hello World.&gt;";
var escapedStr = RegExp.escape(str);
alert(escapedStr == "&lt;Hello\\ World\\.&gt;"); // -&gt; true</pre>
<h1>6. Numbers</h1>
<h2>6.1. Integer Numbers</h2>
<h3>Solution</h3>
<pre>\b[0-9]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A[0-9]+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;=^|\s)[0-9]+(?=$|\s)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Ruby 1.9</p>
<pre>(?:^|(?&lt;=\s))[0-9]+(?=$|\s)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>(^|\s)([0-9]+)(?=$|\s)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>[+-]?\b[0-9]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A[+-]?[0-9]+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^[+-]?[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>([+-] *)?\b[0-9]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.2. Hexadecimal Numbers</h2>
<h3>Solution</h3>
<pre>\b[0-9A-F]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-Fa-f]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A[0-9A-F]+\Z</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^[0-9A-F]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\b0x[0-9A-F]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&amp;H[0-9A-F]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]+H\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]{2}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]{4}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]{8}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]{16}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[0-9A-F]{2})+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.3. Binary Numbers</h2>
<h3>Solution</h3>
<pre>\b[01]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A[01]+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^[01]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\b0b[01]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[01]+B\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[01]{8}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[01]{16}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[01]{8})+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.4. Octal Numbers</h2>
<h3>Solution</h3>
<pre>\b0[0-7]*\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A0[0-7]*\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^0[0-7]*$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\b0o[0-7]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.5. Decimal Numbers</h2>
<h3>Solution</h3>
<pre>\b(0|[1-9][0-9]*)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A(0|[1-9][0-9]*)\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^(0|[1-9][0-9]*)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h2>6.6. Strip Leading Zeros</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>\b0*([1-9][0-9]*|0)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>$1</pre>
<pre>\1</pre>
<h4>Getting the numbers in Perl</h4>
<pre>while ($subject =~ m/\b0*([1-9][0-9]*|0)\b/g) {
    push(@list, $1);
}</pre>
<h4>Stripping leading zeros in PHP</h4>
<pre>$result = preg_replace('/\b0*([1-9][0-9]*|0)\b/', '$1', $subject);</pre>
<h2>6.7. Numbers Within a Certain Range</h2>
<h3>Solution</h3>
<pre>^(1[0-2]|[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(2[0-4]|1[0-9]|[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[01]|[12][0-9]|[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(5[0-3]|[1-4][0-9]|[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[1-5]?[0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(100|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(100|[1-9][0-9]?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(12[0-6]|1[01][0-9]|[4-9][0-9]|3[2-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(12[0-7]|1[01][0-9]|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(12[0-7]|1[01][0-9]|[1-9]?[0-9]|-(12[0-8]|1[01][0-9]|[1-9]?[0-9]))$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(36[0-6]|3[0-5][0-9]|[12][0-9]{2}|[1-9][0-9]?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(19|20)[0-9]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3276[0-7]|327[0-5][0-9]|32[0-6][0-9]{2}|3[01][0-9]{3}|[12][0-9]{4}|[1-9][0-9]{1,3}|[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3276[0-7]|327[0-5][0-9]|32[0-6][0-9]{2}|3[01][0-9]{3}|[12][0-9]{4}|[1-9][0-9]{1,3}|[0-9]|-(3276[0-8]|327[0-5][0-9]|32[0-6][0-9]{2}|3[01][0-9]{3}|[12][0-9]{4}|[1-9][0-9]{1,3}|[0-9]))$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>[45][0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>4[4-9]|5[0-5]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>3[4-9]|[45][0-9]|6[0-5]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>1[0-2]|[1-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>8[5-9]|9[0-9]|10[0-9]|11[0-7]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>6553[0-5]|655[0-2][0-9]|65[0-4][0-9][0-9]|6[0-4][0-9][0-9][0-9]|[1-5][0-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9]|[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{3}|[1-9][0-9]{2}|[1-9][0-9]|[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>6(?:553[0-5]|55[0-2][0-9]|5[0-4][0-9]{2}|[0-4][0-9]{3})|[1-5][0-9]{4}|[1-9][0-9]{1,3}|[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.8. Hexadecimal Numbers Within a Certain Range</h2>
<h3>Solution</h3>
<pre>^[1-9a-c]$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-8]|[1-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-9a-f]|[1-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[0-5]|[12][0-9a-f]|[1-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[0-9a-b]|[12]?[0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(6[0-4]|[1-5]?[0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(6[0-4]|[1-5][0-9a-f]|[1-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(7[0-9a-e]|[2-6][0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[1-7]?[0-9a-f]$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[1-9a-f]?[0-9a-f]$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(16[0-9a-e]|1[0-5][0-9a-f]|[1-9a-f][0-9a-f]?)$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(83[0-3]|8[0-2][0-9a-f]|7[7-9a-f][0-9a-f]|76[c-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^([1-7][0-9a-f]{3}|[1-9a-f][0-9a-f]{1,2}|[0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^([1-9a-f][0-9a-f]{1,3}|[0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.9. Integer Numbers with Separators</h2>
<h3>Solution</h3>
<pre>\b[0-9]+(_+[0-9]+)*\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b0x[0-9A-F]+(_+[0-9A-F]+)*\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b0b[01]+(_+[01]+)*\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b([0-9]+(_+[0-9]+)*|0x[0-9A-F]+(_+[0-9A-F]+)*|0b[01]+(_+[01]+)*)\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A([0-9]+(_+[0-9]+)*|0x[0-9A-F]+(_+[0-9A-F]+)*|0b[01]+(_+[01]+)*)\Z</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^([0-9]+(_+[0-9]+)*|0x[0-9A-F]+(_+[0-9A-F]+)*|0b[01]+(_+[01]+)*)$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h2>6.10. Floating-Point Numbers</h2>
<h3>Solution</h3>
<pre>^[-+][0-9]+\.[0-9]+[eE][-+]?[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+][0-9]+\.[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?[0-9]+\.[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?[0-9]*\.[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?([0-9]+(\.[0-9]+)?|\.[0-9]+)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?([0-9]+(\.[0-9]+)?|\.[0-9]+)([eE][-+]?[0-9]+)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)([eE][-+]?[0-9]+)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>[-+]?(\b[0-9]+(\.[0-9]*)?|\.[0-9]+)([eE][-+]?[0-9]+\b)?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.11. Numbers with Thousand Separators</h2>
<h3>Solution</h3>
<pre>^[0-9]{1,3}(,[0-9]{3})*\.[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[0-9]{1,3}(,[0-9]{3})*(\.[0-9]+)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^([0-9]{1,3}(,[0-9]{3})*(\.[0-9]+)?|\.[0-9]+)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9]{1,3}(,[0-9]{3})*(\.[0-9]+)?\b|\.[0-9]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.12. Add Thousand Separators to Numbers</h2>
<h3>Solution</h3>
<h4>Basic solution</h4>
<pre>[0-9](?=(?:[0-9]{3})+(?![0-9]))</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>$&amp;,</pre>
<pre>$0,</pre>
<pre>\0,</pre>
<pre>\&amp;,</pre>
<pre>\g&lt;0&gt;,</pre>
<h4>Match separator positions only, using lookbehind</h4>
<pre>(?&lt;=[0-9])(?=(?:[0-9]{3})+(?![0-9]))</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>,</pre>
<h3>Variations</h3>
<h4>Don’t add commas after a decimal point</h4>
<pre>[0-9](?=(?:[0-9]{3})+(?![0-9]))(?&lt;!\.[0-9]+)</pre>
<p>Regex options: None<br>
Regex flavors: .NET</p>
<pre>[0-9](?=(?:[0-9]{3})+(?![0-9]))(?&lt;!\.[0-9]{1,100})</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java</p>
<pre>$0,</pre>
<pre>\b(?&lt;!\.)[0-9]{4,}</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>subject.gsub(/\b(?&lt;!\.)[0-9]{4,}/) {|match|
    match.gsub(/[0-9](?=(?:[0-9]{3})+(?![0-9]))/, '\0,')
}</pre>
<pre>subject.replace(/(^|[^0-9.])([0-9]{4,})/g, function($0, $1, $2) {
    return $1 + $2.replace(/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g, "$&amp;,");
});</pre>
<pre>subject.split(").reverse().join(").replace(/[0-9]{3}(?=[0-9])(?![0-9]*\.)/g, "$&amp;,").split(").reverse().join(");</pre>
<pre>function commafy(num) {
    num = String(num);
    var numParts = /^([0-9]+)(\.[0-9]+)?$/.exec(num);
    var result = numParts[1].replace(/[0-9](?=(?:[0-9]{3})+(?![0-9]))/, "$&amp;,");
    if (numParts[2]) {
        result += numParts[2];
    }
    return result;
}

// Test it...
commafy(10000); // "10,000"
commafy(10000.1234); // "10,000.1234"
commafy(.1234); // "0.1234"
commafy("a"); // Throws a TypeError</pre>
<h2>6.13. Roman Numerals</h2>
<h3>Solution</h3>
<pre>^[MDCLXVI]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?=[MDCLXVI])M*(C[MD]|D?C*)(X[CL]|L?X*)(I[XV]|V?I*)$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?=[MDCLXVI])M*D?C{0,4}L?X{0,4}V?I{0,4}$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Convert Roman Numerals to Decimal</h3>
<pre>sub roman2decimal {
    my $roman = shift;
    if ($roman =~
        m/^(?=[MDCLXVI])
          (M*)               # 1000
          (C[MD]|D?C{0,3})   # 100
          (X[CL]|L?X{0,3})   # 10
          (I[XV]|V?I{0,3})   # 1
          $/ix)
    {
        # Roman numeral found
        my %r2d = ('I' =&gt;    1, 'IV' =&gt;   4, 'V' =&gt;   5, 'IX' =&gt;   9,
                   'X' =&gt;   10, 'XL' =&gt;  40, 'L' =&gt;  50, 'XC' =&gt;  90,
                   'C' =&gt;  100, 'CD' =&gt; 400, 'D' =&gt; 500, 'CM' =&gt; 900,
                   'M' =&gt; 1000);
        my $decimal = 0;
        while ($roman =~ m/[MDLV]|C[MD]?|X[CL]?|I[XV]?/ig) {
            $decimal += $r2d{uc($&amp;)};
        }
        return $decimal;
    } else {
        # Not a Roman numeral
        return 0;
    }
}</pre>
<h1>7. Source Code and Log Files</h1>
<h2>7.1. Keywords</h2>
<h3>Solution</h3>
<pre>\b(?:end|in|inline|inherited|item|object)\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?&gt;end|in(?:line|herited)?|item|object)\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>object Button1: TButton
    Caption = 'The end is near'
end</pre>
<pre>\b(end|in|inline|inherited|item|object)\b|'[^'\r\n]*(?:''[^'\r\n]*)*'</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.2. Identifiers</h2>
<h3>Solution</h3>
<pre>\b[a-z_][0-9a-z_]{0,31}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.3. Numeric Constants</h2>
<h3>Solution</h3>
<pre>\b(?:(?&lt;dec&gt;[1-9][0-9]*)
   | (?&lt;oct&gt;0[0-7]*)
   | 0x(?&lt;hex&gt;[0-9A-F]+)
   | 0b(?&lt;bin&gt;[01]+)
  )(?&lt;L&gt;L)?\b</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?:(?P&lt;dec&gt;[1-9][0-9]*)
   | (?P&lt;oct&gt;0[0-7]*)
   | 0x(?P&lt;hex&gt;[0-9A-F]+)
   | 0b(?P&lt;bin&gt;[01]+)
  )(?P&lt;L&gt;L)?\b</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>\b(?:([1-9][0-9]*)|(0[0-7]*)|0x([0-9A-F]+)|0b([01]+))(L)?\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.4. Operators</h2>
<h3>Solution</h3>
<pre>[-+*/=&lt;&gt;%&amp;^|!~?]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.5. Single-Line Comments</h2>
<h3>Solution</h3>
<pre>//.*</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.6. Multiline Comments</h2>
<h3>Solution</h3>
<pre>/\*.*?\*/</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>/\*[\s\S]*?\*/</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>/\*.*?(?:\*/)?</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>/\*[\s\S]*?(?:\*/)?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.7. All Comments</h2>
<h3>Solution</h3>
<pre>(?-s://.*)|(?s:/\*.*?\*/)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl</p>
<pre>(?-m://.*)|(?m:/\*.*?\*/)</pre>
<p>Regex options: None<br>
Regex flavors: Ruby</p>
<pre>//[^\r\n]*|/\*.*?\*/</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>//.*|/\*[\s\S]*?\*/</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.8. Strings</h2>
<h3>Solution</h3>
<pre>"[^"\r\n]*(?:""[^"\r\n]*)*"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>'[^'\r\n]*(?:''[^'\r\n]*)*'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\r\n]*(?:""[^"\r\n]*)*"|'[^'\r\n]*(?:''[^'\r\n]*)*'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"]*(?:""[^"]*)*"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\r\n]*(?:""[^"\r\n]*)*"?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.9. Strings with Escapes</h2>
<h3>Solution</h3>
<pre>"[^"\\\r\n]*(?:\\.[^"\\\r\n]*)"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>'[^'\\\r\n]*(?:\\.[^'\\\r\n]*)'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\\\r\n]*(?:\\.[^"\\\r\n]*)"|'[^'\\\r\n]*(?:\\.[^'\\\r\n]*)'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\\\r\n]*(?:\\(?:.|\r?\n)[^"\\\r\n]*)"</pre>
<p>Regex options: None
        (make sure “dot matches line breaks” is off)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\\]*(?:\\.[^"\\]*)*"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\\]*(?:\\[\s\S][^"\\]*)*"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.10. Regex Literals</h2>
<h3>Solution</h3>
<pre>(?&lt;=[=:(,](?:\s*!)?\s*)/[^/\\\r\n]*(?:\\.[^/\\\r\n]*)*/</pre>
<p>Regex options: None<br>
Regex flavors: .NET</p>
<pre>[=:(,](?:\s*!)?\s*\K/[^/\\\r\n]*(?:\\.[^/\\\r\n]*)*/</pre>
<p>Regex options: None<br>
Regex flavors: PCRE
        7.2, Perl 5.10</p>
<pre>(?&lt;=[=:(,](?:\s{0,10}+!)?\s{0,10})/[^/\\\r\n]*(?:\\.[^/\\\r\n]*)*/</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java</p>
<pre>[=:(,](?:\s*!)?+\s*(/[^/\\\r\n]*(?:\\.[^/\\\r\n]*)*/)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.11. Here Documents</h2>
<h3>Solution</h3>
<pre>&lt;&lt;(["']?)([A-Za-z]+)\b\1.*?^\2\b</pre>
<p>Regex options: Dot
        matches line breaks, ^ and $ match at line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;&lt;(["']?)([A-Za-z]+)\b\1[\s\S]*?^\2\b</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.12. Common Log Format</h2>
<h3>Solution</h3>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;datetime&gt;[^\]]+)\] "(?&lt;method&gt;[A-Z]+) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&lt;status&gt;[0-9]{3}) (?&lt;size&gt;[0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;client&gt;\S+) \S+ (?P&lt;userid&gt;\S+) \[(?P&lt;datetime&gt;[^\]]+)\] "(?P&lt;method&gt;[A-Z]+) (?P&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?P&lt;status&gt;[0-9]{3}) (?P&lt;size&gt;[0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>^(\S+) \S+ (\S+) \[([^\]]+)\] "([A-Z]+) ([^ "]+)? HTTP/[0-9.]+" ([0-9]{3}) ([0-9]+|-) "([^"]*)" "([^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;day&gt;[0-9]{2})/(?&lt;month&gt;[A-Za-z]+)/(?&lt;year&gt;[0-9]{4}):(?&lt;hour&gt;[0-9]{2}):(?&lt;min&gt;[0-9]{2}):(?&lt;sec&gt;[0-9]{2}) (?&lt;zone&gt;[-+][0-9]{4})\] "(?&lt;method&gt;[A-Z]+) (?&lt;file&gt;[^#? "]+)(?&lt;parameters&gt;[#?][^ "]*)? HTTP/[0-9.]+" (?&lt;status&gt;[0-9]{3}) (?&lt;size&gt;[0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;client&gt;\S+) \S+ (?P&lt;userid&gt;\S+) \[(?P&lt;day&gt;[0-9]{2})/(?P&lt;month&gt;[A-Za-z]+)/(?P&lt;year&gt;[0-9]{4}):(?P&lt;hour&gt;[0-9]{2}):(?P&lt;min&gt;[0-9]{2}):(?P&lt;sec&gt;[0-9]{2}) (?P&lt;zone&gt;[-+][0-9]{4})\] "(?P&lt;method&gt;[A-Z]+) (?P&lt;file&gt;[^#? "]+)(?P&lt;parameters&gt;[#?][^ "]*)? HTTP/[0-9.]+" (?P&lt;status&gt;[0-9]{3}) (?P&lt;size&gt;[0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>^(\S+) \S+ (\S+) \[([0-9]{2})/([A-Za-z]+)/([0-9]{4}):([0-9]{2}):([0-9]{2}):([0-9]{2}) ([\-+][0-9]{4})\] "([A-Z]+) ([^#? "]+)([#?][^ "]*)? HTTP/[0-9.]+" ([0-9]{3}) ([0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.13. Combined Log Format</h2>
<h3>Solution</h3>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;datetime&gt;[^\]]+)\] "(?&lt;method&gt;[A-Z]+) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&lt;status&gt;[0-9]{3}) (?&lt;size&gt;[0-9]+|-) "(?&lt;referrer&gt;[^"]*)" "(?&lt;useragent&gt;[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;client&gt;\S+) \S+ (?P&lt;userid&gt;\S+) \[(?P&lt;datetime&gt;[^\]]+)\] "(?P&lt;method&gt;[A-Z]+) (?P&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?P&lt;status&gt;[0-9]{3}) (?P&lt;size&gt;[0-9]+|-) "(?P&lt;referrer&gt;[^"]*)" "(?P&lt;useragent&gt;[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>^(\S+) \S+ (\S+) \[([^\]]+)\] "([A-Z]+) ([^ "]+)? HTTP/[0-9.]+" ([0-9]{3}) ([0-9]+|-) "([^"]*)" "([^"]*)" "([^"]*)" "([^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.14. Broken Links Reported in Web Logs</h2>
<h3>Solution</h3>
<pre>"(?:GET|POST) (?&lt;file&gt;[^#? "]+)(?:[#?][^ "]*)? HTTP/[0-9.]+" 404 (?:[0-9]+|-) "(?&lt;referrer&gt;http://www\.yoursite\.com[^"]*)"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>"(?:GET|POST) (?P&lt;file&gt;[^#? "]+)(?:[#?][^ "]*)? HTTP/[0-9.]+" 404 (?:[0-9]+|-) "(?P&lt;referrer&gt;http://www\.yoursite\.com[^"]*)"</pre>
<p>Regex options: None<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>"(?:GET|POST) ([^#? "]+)(?:[#?][^ "]*)? HTTP/[0-9.]+" 404 (?:[0-9]+|-) "(http://www\.yoursite\.com[^"]*)"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;datetime&gt;[^\]]+)\] "(?&lt;method&gt;[A-Z]+) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&lt;status&gt;404) (?&lt;size&gt;[0-9]+|-) "(?&lt;referrer&gt;http://www\.yoursite\.com[^"]*)" "(?&lt;useragent&gt;[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;datetime&gt;[^\]]+)\] "(?&lt;method&gt;[A-Z]+) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&lt;status&gt;404) (?&lt;size&gt;[0-9]+|-) "(?&lt;referrer&gt;http://www\.yoursite\.com[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>"(?&lt;method&gt;GET|POST) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&lt;status&gt;404) (?&lt;size&gt;[0-9]+|-) "(?&lt;referrer&gt;http://www\.yoursite\.com[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h1>8. URLs, Paths, and Internet Addresses</h1>
<h2>8.1. Validating URLs</h2>
<h3>Solution</h3>
<pre>^(https?|ftp|file)://.+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A(https?|ftp|file)://.+\Z</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\A                         # Anchor
(https?|ftp)://            # Scheme
[a-z0-9-]+(\.[a-z0-9-]+)+  # Domain
([/?].*)?                  # Path and/or parameters
\Z                         # Anchor</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^(https?|ftp)://[a-z0-9-]+(\.[a-z0-9-]+)+([/?].+)?$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A                             # Anchor
((https?|ftp)://|(www|ftp)\.)  # Scheme or subdomain
[a-z0-9-]+(\.[a-z0-9-]+)+      # Domain
([/?].*)?                      # Path and/or parameters
\Z                             # Anchor</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^((https?|ftp)://|(www|ftp)\.)[a-z0-9-]+(\.[a-z0-9-]+)+([/?].*)?$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A                         # Anchor
(https?|ftp)://            # Scheme
[a-z0-9-]+(\.[a-z0-9-]+)+  # Domain
(/[\w-]+)*                 # Path
/[\w-]+\.(gif|png|jpg)     # File
\Z                         # Anchor</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^(https?|ftp)://[a-z0-9-]+(\.[a-z0-9-]+)+(/[\w-]+)*/[\w-]+\.(gif|png|jpg)$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.2. Finding URLs Within Full Text</h2>
<h3>Solution</h3>
<pre>\b(https?|ftp|file)://\S+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(https?|ftp|file)://[-A-Z0-9+&amp;@#/%?=~_|$!:,.;]*[A-Z0-9+&amp;@#/%=~_|$]</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b((https?|ftp|file)://|(www|ftp)\.)[-A-Z0-9+&amp;@#/%?=~_|$!:,.;]*[A-Z0-9+&amp;@#/%=~_|$]</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.3. Finding Quoted URLs in Full Text</h2>
<h3>Solution</h3>
<pre>\b(?:(?:https?|ftp|file)://|(www|ftp)\.)[-A-Z0-9+&amp;@#/%?=~_|$!:,.;]*
                                        [-A-Z0-9+&amp;@#/%=~_|$]
|"(?:(?:https?|ftp|file)://|(www|ftp)\.)[^"\r\n]+"
|'(?:(?:https?|ftp|file)://|(www|ftp)\.)[^'\r\n]+'</pre>
<p>Regex options: Free-spacing, case insensitive, dot matches line breaks, anchors match
        at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.4. Finding URLs with Parentheses in Full Text</h2>
<h3>Solution</h3>
<pre>\b(?:(?:https?|ftp|file)://|www\.|ftp\.)
  (?:\([-A-Z0-9+&amp;@#/%=~_|$?!:,.]*\)|[-A-Z0-9+&amp;@#/%=~_|$?!:,.])*
  (?:\([-A-Z0-9+&amp;@#/%=~_|$?!:,.]*\)|[A-Z0-9+&amp;@#/%=~_|$])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:(?:https?|ftp|file)://|www\.|ftp\.)(?:\([-A-Z0-9+&amp;@#/%=~_|$?!:,.]*\)|[-A-Z0-9+&amp;@#/%=~_|$?!:,.])*(?:\([-A-Z0-9+&amp;@#/%=~_|$?!:,.]*\)|[A-Z0-9+&amp;@#/%=~_|$])</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>http://en.wikipedia.org/wiki/PC_Tools_(Central_Point_Software)
http://msdn.microsoft.com/en-us/library/aa752574(VS.85).aspx</pre>
<pre>RegexBuddy's website (at http://www.regexbuddy.com) is really cool.</pre>
<pre>[-A-Z0-9+&amp;@#/%=~_|$?!:,.]</pre>
<pre>\([-A-Z0-9+&amp;@#/%=~_|$?!:,.]*\)|[-A-Z0-9+&amp;@#/%=~_|$?!:,.]</pre>
<pre>[A-Z0-9+&amp;@#/%=~_|$]</pre>
<pre>\([-A-Z0-9+&amp;@#/%=~_|$?!:,.]*\)|[A-Z0-9+&amp;@#/%=~_|$]</pre>
<h2>8.5. Turn URLs into Links</h2>
<h3>Solution</h3>
<pre>&lt;a href="$&amp;"&gt;$&amp;&lt;/a&gt;</pre>
<pre>&lt;a href="$0"&gt;$0&lt;/a&gt;</pre>
<pre>&lt;a href="\0"&gt;\0&lt;/a&gt;</pre>
<pre>&lt;a href="\&amp;"&gt;\&amp;&lt;/a&gt;</pre>
<pre>&lt;a href="\g&lt;0&gt;"&gt;\g&lt;0&gt;&lt;/a&gt;</pre>
<h2>8.6. Validating URNs</h2>
<h3>Solution</h3>
<pre>\Aurn:
# Namespace Identifier
[a-z0-9][a-z0-9-]{0,31}:
# Namespace Specific String
[a-z0-9()+,\-.:=@;$_!*'%/?#]+
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^urn:[a-z0-9][a-z0-9-]{0,31}:[a-z0-9()+,\-.:=@;$_!*'%/?#]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\burn:
# Namespace Identifier
[a-z0-9][a-z0-9-]{0,31}:
# Namespace Specific String
[a-z0-9()+,\-.:=@;$_!*'%/?#]+</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\burn:[a-z0-9][a-z0-9-]{0,31}:[a-z0-9()+,\-.:=@;$_!*'%/?#]+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\burn:
# Namespace Identifier
[a-z0-9][a-z0-9-]{0,31}:
# Namespace Specific String
[a-z0-9()+,\-.:=@;$_!*'%/?#]*[a-z0-9+=@$/]</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\burn:[a-z0-9][a-z0-9-]{0,31}:[a-z0-9()+,\-.:=@;$_!*'%/?#]*[a-z0-9+=@$/]</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>The URN is urn:nid:nss, isn't it?</pre>
<h2>8.7. Validating Generic URLs</h2>
<h3>Solution</h3>
<pre>\A
(# Scheme
 [a-z][a-z0-9+\-.]*:
 (# Authority &amp; path
  //
  ([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User
  ([a-z0-9\-._~%]+                            # Named host
  |\[[a-f0-9:.]+\]                            # IPv6 host
  |\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host
  (:[0-9]+)?                                  # Port
  (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path
 |# Path without authority
  (/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?
 )
|# Relative URL (no scheme or authority)
 (# Relative path
  [a-z0-9\-._~%!$&amp;'()*+,;=@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?
 |# Absolute path
  (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)+/?
 )
)
# Query
(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
# Fragment
(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\A
(# Scheme
 (?&lt;scheme&gt;[a-z][a-z0-9+\-.]*):
 (# Authority &amp; path
  //
  (?&lt;user&gt;[a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User
  (?&lt;host&gt;[a-z0-9\-._~%]+                            # Named host
  |       \[[a-f0-9:.]+\]                            # IPv6 host
  |       \[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host
  (?&lt;port&gt;:[0-9]+)?                                  # Port
  (?&lt;path&gt;(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)        # Path
 |# Path without authority
  (?&lt;path&gt;/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+
          (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?
 )
|# Relative URL (no scheme or authority)
 (?&lt;path&gt;
  # Relative path
  [a-z0-9\-._~%!$&amp;'()*+,;=@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?
 |# Absolute path
  (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)+/?
 )
)
# Query
(?&lt;query&gt;\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
# Fragment
(?&lt;fragment&gt;\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Perl 5.10, Ruby 1.9</p>
<pre>\A
(# Scheme
 (?&lt;scheme&gt;[a-z][a-z0-9+\-.]*):
 (# Authority &amp; path
  //
  (?&lt;user&gt;[a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User
  (?&lt;host&gt;[a-z0-9\-._~%]+                            # Named host
  |       \[[a-f0-9:.]+\]                            # IPv6 host
  |       \[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host
  (?&lt;port&gt;:[0-9]+)?                                  # Port
  (?&lt;hostpath&gt;(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)    # Path
 |# Path without authority
  (?&lt;schemepath&gt;/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+
                (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?
 )
|# Relative URL (no scheme or authority)
 (?&lt;relpath&gt;
  # Relative path
  [a-z0-9\-._~%!$&amp;'()*+,;=@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?
 |# Absolute path
  (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)+/?
 )
)
# Query
(?&lt;query&gt;\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
# Fragment
(?&lt;fragment&gt;\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(# Scheme
 (?P&lt;scheme&gt;[a-z][a-z0-9+\-.]*):
 (# Authority &amp; path
  //
  (?P&lt;user&gt;[a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User
  (?P&lt;host&gt;[a-z0-9\-._~%]+                            # Named host
  |       \[[a-f0-9:.]+\]                             # IPv6 host
  |       \[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])   # IPvFuture host
  (?P&lt;port&gt;:[0-9]+)?                                  # Port
  (?P&lt;hostpath&gt;(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)    # Path
 |# Path without authority
  (?P&lt;schemepath&gt;/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+
                 (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?
 )
|# Relative URL (no scheme or authority)
 (?P&lt;relpath&gt;
  # Relative path
  [a-z0-9\-._~%!$&amp;'()*+,;=@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?
 |# Absolute path
  (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)+/?
 )
)
# Query
(?P&lt;query&gt;\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
# Fragment
(?P&lt;fragment&gt;\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
        and later, Perl 5.10, Python</p>
<pre>^([a-z][a-z0-9+\-.]*:(\/\/([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?([a-z0-9\-._~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])(:[0-9]+)?(\/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*\/?|(\/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+(\/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*\/?)?)|([a-z0-9\-._~%!$&amp;'()*+,;=@]+(\/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*\/?|(\/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)+\/?))
(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@\/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=:@\/?]*)?$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.8. Extracting the Scheme from a URL</h2>
<h3>Solution</h3>
<h4>Extract the scheme from a URL known to be valid</h4>
<pre>^([a-z][a-z0-9+\-.]*):</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Extract the scheme while validating the URL</h4>
<pre>\A
([a-z][a-z0-9+\-.]*):
(# Authority &amp; path
 //
 ([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User
 ([a-z0-9\-._~%]+                            # Named host
 |\[[a-f0-9:.]+\]                            # IPv6 host
 |\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host
 (:[0-9]+)?                                  # Port
 (/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path
|# Path without authority
 (/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?
)
# Query
(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
# Fragment
(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?
\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z][a-z0-9+\-.]*):(//([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?([a-z0-9\-._~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])(:[0-9]+)?(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?|(/?[a-z0-9\-._~%!$&amp;'()*+,;=:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?)?)(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.9. Extracting the User from a URL</h2>
<h3>Solution</h3>
<h4>Extract the user from a URL known to be valid</h4>
<pre>^[a-z0-9+\-.]+://([a-z0-9\-._~%!$&amp;'()*+,;=]+)@</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Extract the user while validating the URL</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://                       # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=]+)@               # User
([a-z0-9\-._~%]+                            # Named host
|\[[a-f0-9:.]+\]                            # IPv6 host
|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host
(:[0-9]+)?                                  # Port
(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path
(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Query
(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Fragment
\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~%!$&amp;'()*+,;=]+)@([a-z0-9\-._~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])(:[0-9]+)?(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.10. Extracting the Host from a URL</h2>
<h3>Solution</h3>
<h4>Extract the host from a URL known to be valid</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://               # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?      # User
([a-z0-9\-._~%]+                    # Named or IPv4 host
|\[[a-z0-9\-._~%!$&amp;'()*+,;=:]+\])   # IPv6+ host</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?([a-z0-9\-._~%]+|\[[a-z0-9\-._~%!$&amp;'()*+,;=:]+\])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Extract the host while validating the URL</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://                       # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User
([a-z0-9\-._~%]+                            # Named host
|\[[a-f0-9:.]+\]                            # IPv6 host
|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host
(:[0-9]+)?                                  # Port
(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path
(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Query
(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Fragment
\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?([a-z0-9\-._~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])(:[0-9]+)?(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.11. Extracting the Port from a URL</h2>
<h3>Solution</h3>
<h4>Extract the port from a URL known to be valid</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://               # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?      # User
([a-z0-9\-._~%]+                    # Named or IPv4 host
|\[[a-z0-9\-._~%!$&amp;'()*+,;=:]+\])   # IPv6+ host
:(?&lt;port&gt;[0-9]+)                    # Port number</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
[a-z][a-z0-9+\-.]*://               # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?      # User
([a-z0-9\-._~%]+                    # Named or IPv4 host
|\[[a-z0-9\-._~%!$&amp;'()*+,;=:]+\])   # IPv6+ host
:(?P&lt;port&gt;[0-9]+)                   # Port number</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE,
          Perl 5.10, Python</p>
<pre>^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?([a-z0-9\-._~%]+|\[[a-z0-9\-._~%!$&amp;'()*+,;=:]+\]):([0-9]+)</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Extract the port while validating the URL</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://                       # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?              # User
([a-z0-9\-._~%]+                            # Named host
|\[[a-f0-9:.]+\]                            # IPv6 host
|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\])  # IPvFuture host
:([0-9]+)                                   # Port
(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?          # Path
(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Query
(\#[a-z0-9\-._~%!$&amp;'()*+,;=:@/?]*)?         # Fragment
\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z][a-z0-9+\-.]*:\/\/([a-z0-9\-._~%!$&amp;'()*+,;=]+@)?([a-z0-9\-._~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=:]+\]):([0-9]+)(\/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*\/?(\?[a-z0-9\-._~%!$&amp;'()*+,;=:@\/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=:@\/?]*)?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.12. Extracting the Path from a URL</h2>
<h3>Solution</h3>
<pre>\A
# Skip over scheme and authority, if any
([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?
# Path
([a-z0-9\-._~%!$&amp;'()*+,;=:@/]*)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?([a-z0-9\-._~%!$&amp;'()*+,;=:@/]*)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A
# Skip over scheme and authority, if any
([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?
# Path
(/?[a-z0-9\-._~%!$&amp;'()*+,;=@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?|/)
# Query, fragment, or end of URL
([#?]|\Z)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?(/?[a-z0-9\-._~%!$&amp;'()*+,;=@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=:@]+)*/?|/)([#?]|$)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A
# Skip over scheme and authority, if any
(?&gt;([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?)
# Path
([a-z0-9\-._~%!$&amp;'()*+,;=:@/]+)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Ruby</p>
<h2>8.13. Extracting the Query from a URL</h2>
<h3>Solution</h3>
<pre>^[^?#]+\?([^#]+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.14. Extracting the Fragment from a URL</h2>
<h3>Solution</h3>
<pre>#(.+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.15. Validating Domain Names</h2>
<h3>Solution</h3>
<pre>^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\Z</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\b([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b((?=[a-z0-9-]{1,63}\.)[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,63}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b((xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b((?=[a-z0-9-]{1,63}\.)(xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,63}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.16. Matching IPv4 Addresses</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Perl</h4>
<pre>if ($subject =~ m/^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/)
{
    $ip = $1 &lt;&lt; 24 | $2 &lt;&lt; 16 | $3 &lt;&lt; 8 | $4;
}</pre>
<h2>8.17. Matching IPv6 Addresses</h2>
<h3>Solution</h3>
<h4>Standard notation</h4>
<pre>^(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>(?&lt;![:.\w])(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>\b(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Mixed notation</h4>
<pre>^(?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?&lt;![:.\w])(?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Standard or mixed notation</h4>
<pre>\A                                                       # Start of string
(?:[A-F0-9]{1,4}:){6}                                        # 6 words
(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}                               # 2 words
|  (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # or 4 bytes
   (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
)\Z                                                      # End of string</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:[A-F0-9]{1,4}:){6}(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}|(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]))$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;![:.\w])                                              # Anchor address
(?:[A-F0-9]{1,4}:){6}                                        # 6 words
(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}                               # 2 words
|  (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # or 4 bytes
   (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
)(?![:.\w])                                              # Anchor address</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>\b                                                       # Word boundary
(?:[A-F0-9]{1,4}:){6}                                        # 6 words
(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}                               # 2 words
|  (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # or 4 bytes
   (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
)\b                                                      # Word boundary</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[A-F0-9]{1,4}:){6}(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}|(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]))\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Compressed notation</h4>
<pre>\A(?:
 # Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
 # Compressed with at most 7 colons
|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    \Z) # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}$)(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;![:.\w])(?:
 # Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
 # Compressed with at most 7 colons
|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    (?![:.\w])) # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>(?:
 # Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
 # Compressed with at most 7 colons
|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    (?![:.\w])) # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>(?:(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}(?![:.\w]))(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Compressed mixed notation</h4>
<pre>\A
(?:
 # Non-compressed
 (?:[A-F0-9]{1,4}:){6}
 # Compressed with at most 6 colons
|(?=(?:[A-F0-9]{0,4}:){0,6}
    (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
    \Z)                            # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
 # Compressed with 7 colons and 5 numbers
|::(?:[A-F0-9]{1,4}:){5}
)
# 255.255.255.
(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
# 255
(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:[A-F0-9]{1,4}:){6}|(?=(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.){3}[0-9]{1,3}$)(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;![:.\w])
(?:
 # Non-compressed
 (?:[A-F0-9]{1,4}:){6}
 # Compressed with at most 6 colons
|(?=(?:[A-F0-9]{0,4}:){0,6}
    (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
    (?![:.\w]))                    # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
 # Compressed with 7 colons and 5 numbers
|::(?:[A-F0-9]{1,4}:){5}
)
# 255.255.255.
(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
# 255
(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>(?:
 # Non-compressed
 (?:[A-F0-9]{1,4}:){6}
 # Compressed with at most 6 colons
|(?=(?:[A-F0-9]{0,4}:){0,6}
    (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
    (?![:.\w]))                    # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
 # Compressed with 7 colons and 5 numbers
|::(?:[A-F0-9]{1,4}:){5}
)
# 255.255.255.
(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
# 255
(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>(?:(?:[A-F0-9]{1,4}:){6}|(?=(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.){3}[0-9]{1,3}(?![:.\w]))(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Standard, mixed, or compressed notation</h4>
<pre>\A(?:
# Mixed
 (?:
  # Non-compressed
  (?:[A-F0-9]{1,4}:){6}
  # Compressed with at most 6 colons
 |(?=(?:[A-F0-9]{0,4}:){0,6}
     (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
     \Z)                            # and anchored
  # and at most 1 double colon
  (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
  # Compressed with 7 colons and 5 numbers
 |::(?:[A-F0-9]{1,4}:){5}
 )
 # 255.255.255.
 (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
 # 255
 (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
|# Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
|# Compressed with at most 7 colons
 (?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    \Z)  # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:(?:[A-F0-9]{1,4}:){6}|(?=(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.){3}[0-9]{1,3}$)(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])|(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}$)(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;![:.\w])(?:
# Mixed
 (?:
  # Non-compressed
  (?:[A-F0-9]{1,4}:){6}
  # Compressed with at most 6 colons
 |(?=(?:[A-F0-9]{0,4}:){0,6}
     (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
     (?![:.\w]))                    # and anchored
  # and at most 1 double colon
  (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
  # Compressed with 7 colons and 5 numbers
 |::(?:[A-F0-9]{1,4}:){5}
 )
 # 255.255.255.
 (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
 # 255
 (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
|# Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
|# Compressed with at most 7 colons
 (?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    (?![:.\w]))  # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>(?:
 # Mixed
 (?:
  # Non-compressed
  (?:[A-F0-9]{1,4}:){6}
  # Compressed with at most 6 colons
 |(?=(?:[A-F0-9]{0,4}:){0,6}
     (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
     (?![:.\w]))                    # and anchored
  # and at most 1 double colon
  (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
  # Compressed with 7 colons and 5 numbers
 |::(?:[A-F0-9]{1,4}:){5}
 )
 # 255.255.255.
 (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
 # 255
 (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
|# Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
|# Compressed with at most 7 colons
 (?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    (?![:.\w]))  # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>(?:(?:(?:[A-F0-9]{1,4}:){6}|(?=(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.){3}[0-9]{1,3}(?![:.\w]))(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}(?![:.\w]))(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<h4>Compressed notation</h4>
<pre>(
  ([0-9A-F]{1,4}:){1,7}  # 1 to 7 words to the left
| :                      # or a double colon at the start
)
(
  (:[0-9A-F]{1,4}){1,7}  # 1 to 7 words to the right
| :                      # or a double colon at the end
)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>\A(?:a{7}x
 |  a{6}xb?
 |  a{5}xb{0,2}
 |  a{4}xb{0,3}
 |  a{3}xb{0,4}
 |  a{2}xb{0,5}
 |  axb{0,6}
 |  xb{0,7}
)\Z</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>\A
  (?=[abx]{1,8}\Z)
  a{0,7}xb{0,7}
\Z</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Standard, mixed, or compressed notation</h4>
<pre>^(6words|compressed6words)ip4$</pre>
<pre>^(8words|compressed8words)$</pre>
<pre>^((6words|compressed6words)ip4|8words|compressed8words)$</pre>
<pre>^((6words|compressed6words)ip4|(8words|compressed8words))$</pre>
<h2>8.18. Validate Windows Paths</h2>
<h3>Solution</h3>
<h4>Drive letter paths</h4>
<pre>\A
[a-z]:\\                    # Drive
(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*   # Folder
[^\\/:*?"&lt;&gt;|\r\n]*          # File
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z]:\\(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*[^\\/:*?"&lt;&gt;|\r\n]*$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h4>Drive letter and UNC paths</h4>
<pre>\A
(?:[a-z]:|\\\\[a-z0-9_.$\ -]+\\[a-z0-9_.$\ -]+)\\   # Drive
(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*                            # Folder
[^\\/:*?"&lt;&gt;|\r\n]*                                   # File
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*[^\\/:*?"&lt;&gt;|\r\n]*$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h4>Drive letter, UNC, and relative paths</h4>
<pre>\A
(?:(?:[a-z]:|\\\\[a-z0-9_.$\ -]+\\[a-z0-9_.$\ -]+)\\|  # Drive
   \\?[^\\/:*?"&lt;&gt;|\r\n]+\\?)                            # Relative path
(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*                               # Folder
[^\\/:*?"&lt;&gt;|\r\n]*                                      # File
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\|\\?[^\\/:*?"&lt;&gt;|\r\n]+\\?)(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*[^\\/:*?"&lt;&gt;|\r\n]*$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.19. Split Windows Paths into Their Parts</h2>
<h3>Solution</h3>
<h4>Drive letter paths</h4>
<pre>\A
(?&lt;drive&gt;[a-z]:)\\
(?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(?P&lt;drive&gt;[a-z]:)\\
(?P&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?P&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<pre>\A
([a-z]:)\\
((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
([^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z]:)\\((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)([^\\/:*?"&lt;&gt;|\r\n]*)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h4>Drive letter and UNC paths</h4>
<pre>\A
(?&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
(?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(?P&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
(?P&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?P&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<pre>\A
([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
([^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)([^\\/:*?"&lt;&gt;|\r\n]*)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h4>Drive letter, UNC, and relative paths</h4>
<pre>\A
(?&lt;drive&gt;[a-z]:\\|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+\\|\\?)
(?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(?P&lt;drive&gt;[a-z]:\\|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+\\|\\?)
(?P&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?P&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<pre>\A
([a-z]:\\|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+\\|\\?)
((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
([^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z]:\\|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+\\|\\?)((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)([^\\/:*?"&lt;&gt;|\r\n]*)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h3>Discussion</h3>
<h4>Drive letter, UNC, and relative paths</h4>
<pre>\A
(?:
   (?&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
   (?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
   (?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?&lt;relativefolder&gt;\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)
   (?&lt;file2&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?&lt;relativefile&gt;[^\\/:*?"&lt;&gt;|\r\n]+)
)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(?:
   (?P&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
   (?P&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
   (?P&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?P&lt;relativefolder&gt;\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)
   (?P&lt;file2&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?P&lt;relativefile&gt;[^\\/:*?"&lt;&gt;|\r\n]+)
)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<pre>\A
(?:
   ([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
   ((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
   ([^\\/:*?"&lt;&gt;|\r\n]*)
|  (\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)
   ([^\\/:*?"&lt;&gt;|\r\n]*)
|  ([^\\/:*?"&lt;&gt;|\r\n]+)
)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)([^\\/:*?"&lt;&gt;|\r\n]*)|(\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)([^\\/:*?"&lt;&gt;|\r\n]*)|([^\\/:*?"&lt;&gt;|\r\n]+))$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A
(?:
   (?&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
   (?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
   (?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?&lt;folder&gt;\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)
   (?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]+)
)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Perl 5.10, Ruby 1.9</p>
<h2>8.20. Extract the Drive Letter from a Windows Path</h2>
<h3>Solution</h3>
<pre>^([a-z]):</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.21. Extract the Server and Share from a UNC Path</h2>
<h3>Solution</h3>
<pre>^\\\\([a-z0-9_.$ -]+)\\([a-z0-9_.$ -]+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.22. Extract the Folder from a Windows Path</h2>
<h3>Solution</h3>
<pre>^([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)?((?:\\|^)(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>^([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)?((?:\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)</pre>
<h2>8.23. Extract the Filename from a Windows Path</h2>
<h3>Solution</h3>
<pre>[^\\/:*?"&lt;&gt;|\r\n]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.24. Extract the File Extension from a Windows Path</h2>
<h3>Solution</h3>
<pre>\.[^.\\/:*?"&lt;&gt;|\r\n]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.25. Strip Invalid Characters from Filenames</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>[\\/:"*?&lt;&gt;|]+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h1>9. Markup and Data Formats</h1>
<h3>Basic Rules for Formats Covered in This Chapter</h3>
<pre>&lt;a href="http://www.regexcookbook.com"
    title = 'Regex Cookbook'&gt;Click me!&lt;/a&gt;</pre>
<pre>&lt;!-- this is a comment --&gt;
&lt;!-- so is this, but this comment
    spans more than one line --&gt;</pre>
<pre>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd"&gt;</pre>
<pre>&lt;!DOCTYPE html&gt;</pre>
<pre>&lt;!DOCTYPE example [
  &lt;!ENTITY copy "&amp;#169;"&gt;
  &lt;!ENTITY copyright-notice "Copyright &amp;copy; 2012, O'Reilly"&gt;
]&gt;</pre>
<pre>aaa,b b,"""c"" cc"
1,,"333, three,
still more threes"</pre>
<pre>333, three,
still more threes</pre>
<pre>; last modified 2012-02-14

[user]
name=J. Random Hacker

[post]
title = How do I love thee, regular expressions?
content = "Let me count the ways..."</pre>
<h2>9.1. Find XML-Style Tags</h2>
<h3>Solution</h3>
<h4>Quick and dirty</h4>
<pre>&lt;[^&gt;]*&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Allow &gt; in attribute values</h4>
<pre>&lt;(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?: [^&gt;"']   # Non-quoted character
  | "[^"]*"  # Double-quoted attribute value
  | '[^']*'  # Single-quoted attribute value
)*
&gt;</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>(X)HTML tags (loose)</h4>
<pre>&lt;/?([A-Za-z][^\s&gt;/]*)(?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
/?                  # Permit closing tags
([A-Za-z][^\s&gt;/]*)  # Capture the tag name to backreference 1
(?:                 # Attribute value branch:
  = \s*             #   Signals the start of an attribute value
  (?: "[^"]*"       #   Double-quoted attribute value
    | '[^']*'       #   Single-quoted attribute value
    | [^\s&gt;]+       #   Unquoted attribute value
  )
|                   # Non-attribute-value branch:
  [^&gt;]              #   Character outside of an attribute value
)*
(?:&gt;|$)             # End of the tag or string</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>(X)HTML tags (strict)</h4>
<pre>&lt;(?:([A-Z][-:A-Z0-9]*)(?:\s+[A-Z][-:A-Z0-9]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^"'`=&lt;&gt;\s]+))?)*\s*/?|/([A-Z][-:A-Z0-9]*)\s*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?:                    # Branch for opening tags:
  ([A-Z][-:A-Z0-9]*)   #   Capture the opening tag name to backreference 1
  (?:                  #   This group permits zero or more attributes
    \s+                #   Whitespace to separate attributes
    [A-Z][-:A-Z0-9]*   #   Attribute name
    (?: \s*=\s*        #   Attribute name-value delimiter
      (?: "[^"]*"      #   Double-quoted attribute value
        | '[^']*'      #   Single-quoted attribute value
        | [^"'`=&lt;&gt;\s]+ #   Unquoted attribute value (HTML)
      )
    )?                 #   Permit attributes without a value (HTML)
  )*
  \s*                  #   Permit trailing whitespace
  /?                   #   Permit self-closed tags
|                      # Branch for closing tags:
  /
  ([A-Z][-:A-Z0-9]*)   #   Capture the closing tag name to backreference 2
  \s*                  #   Permit trailing whitespace
)
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>XML tags (strict)</h4>
<pre>&lt;(?:([_:A-Z][-.:\w]*)(?:\s+[_:A-Z][-.:\w]*\s*=\s*(?:"[^"]*"|'[^']*'))*\s*/?|/([_:A-Z][-.:\w]*)\s*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?:                  # Branch for opening tags:
  ([_:A-Z][-.:\w]*)  #   Capture the opening tag name to backreference 1
  (?:                #   This group permits zero or more attributes
    \s+              #   Whitespace to separate attributes
    [_:A-Z][-.:\w]*  #   Attribute name
    \s*=\s*          #   Attribute name-value delimiter
    (?: "[^"]*"      #   Double-quoted attribute value
      | '[^']*'      #   Single-quoted attribute value
    )
  )*
  \s*                #   Permit trailing whitespace
  /?                 #   Permit self-closed tags
|                    # Branch for closing tags:
  /
  ([_:A-Z][-.:\w]*)  #   Capture the closing tag name to backreference 2
  \s*                #   Permit trailing whitespace
)
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<h4>Allow &gt; in attribute values</h4>
<pre>&lt;(?&gt;(?:(?&gt;[^&gt;"']+)|"[^"]*"|'[^']*')*)&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, PCRE, Perl, Ruby</p>
<pre>&lt;(?:[^&gt;"']++|"[^"]*"|'[^']*')*+&gt;</pre>
<p>Regex options: None<br>
Regex flavors: Java, PCRE, Perl 5.10, Ruby 1.9</p>
<h4>(X)HTML tags (loose)</h4>
<pre>&lt;([A-Za-z][^\s&gt;/]*)(?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;/])*(?:&gt;|$)</pre>
<pre>&lt;([A-Za-z][^\s&gt;/]*)(?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*(?:/&gt;|$)</pre>
<pre>&lt;([A-Za-z][^\s&gt;/]*)(?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/([A-Za-z][^\s&gt;/]*)(?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/?([A-Za-z](?&gt;[^\s&gt;/]*))(?&gt;=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, PCRE, Perl, Ruby</p>
<pre>&lt;/?([A-Za-z][^\s&gt;/]*+)(?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*+(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: Java, PCRE, Perl 5.10, Ruby 1.9</p>
<pre>&lt;/?([A-Za-z](?=([^\s&gt;/]*))\2)(?=((?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*))\3(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>(X)HTML tags (strict)</h4>
<pre>&lt;([A-Z][-:A-Z0-9]*)(?:\s+[A-Z][-:A-Z0-9]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^"'`=&lt;&gt;\s]+))?)*\s*/?&gt;</pre>
<p>Regex options: Case insensitive<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/([A-Z][-:A-Z0-9]*)\s*&gt;</pre>
<p>Regex options: Case insensitive<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>XML tags (strict)</h4>
<pre>&lt;([_:A-Z][-.:\w]*)(?:\s+[_:A-Z][-.:\w]*\s*=\s*(?:"[^"]*"|'[^']*'))*\s*/?&gt;</pre>
<p>Regex options: Case insensitive<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/([_:A-Z][-.:\w]*)\s*&gt;</pre>
<p>Regex options: Case insensitive<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Skip Tricky (X)HTML and XML Sections</h3>
<h4>Outer regex for (X)HTML</h4>
<pre>&lt;!--.*?--&gt;|&lt;!\[CDATA\[.*?]]&gt;|&lt;(script|style|textarea|title|xmp)\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;.*?&lt;/\1\s*&gt;|&lt;plaintext\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;.*</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre># Comment
&lt;!-- .*? --&gt;
|
# CDATA section
&lt;!\[CDATA\[ .*? ]]&gt;
|
# Special element and its content
&lt;( script | style | textarea | title | xmp )\b
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt; .*? &lt;/\1\s*&gt;
|
# &lt;plaintext/&gt; continues until the end of the string
&lt;plaintext\b
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt; .*</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--[\s\S]*?--&gt;|&lt;!\[CDATA\[[\s\S]*?]]&gt;|&lt;(script|style|textarea|title|xmp)\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;[\s\S]*?&lt;/\1\s*&gt;|&lt;plaintext\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;[\s\S]*</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Outer regex for XML</h4>
<pre>&lt;!--.*?--\s*&gt;|&lt;!\[CDATA\[.*?]]&gt;|&lt;!DOCTYPE\s(?:[^&lt;&gt;"']|"[^"]*"|'[^']*'|&lt;!(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;)*&gt;</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre># Comment
&lt;!-- .*? --\s*&gt;
|
# CDATA section
&lt;!\[CDATA\[ .*? ]]&gt;
|
# Document type declaration
&lt;!DOCTYPE\s
    (?: [^&lt;&gt;"']  # Non-special character
      | "[^"]*"  # Double-quoted value
      | '[^']*'  # Single-quoted value
      | &lt;!(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;  # Markup declaration
    )*
&gt;</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--[\s\S]*?--\s*&gt;|&lt;!\[CDATA\[[\s\S]*?]]&gt;|&lt;!DOCTYPE\s(?:[^&lt;&gt;"']|"[^"]*"|'[^']*'|&lt;!(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;)*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.2. Replace &lt;b&gt; Tags with &lt;strong&gt;</h2>
<h3>Solution</h3>
<pre>&lt;(/?)b\b((?:[^&gt;"']|"[^"]*"|'[^']*')*)&gt;</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(/?)             # Capture the optional leading slash to backreference 1
b \b             # Tag name, with word boundary
(                # Capture any attributes, etc. to backreference 2
    (?: [^&gt;"']   # Any character except &gt;, ", or '
      | "[^"]*"  # Double-quoted attribute value
      | '[^']*'  # Single-quoted attribute value
    )*
)
&gt;</pre>
<p>Regex options: Case
        insensitive, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;$1strong$2&gt;</pre>
<pre>&lt;\1strong\2&gt;</pre>
<pre>&lt;$1strong&gt;</pre>
<pre>&lt;\1strong&gt;</pre>
<h3>Variations</h3>
<h4>Replace a list of tags</h4>
<pre>&lt;(/?)([bi]|em|big)\b((?:[^&gt;"']|"[^"]*"|'[^']*')*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(/?)              # Capture the optional leading slash to backreference 1
([bi]|em|big) \b  # Capture the tag name to backreference 2
(                 # Capture any attributes, etc. to backreference 3
    (?: [^&gt;"']    # Any character except &gt;, ", or '
      | "[^"]*"   # Double-quoted attribute value
      | '[^']*'   # Single-quoted attribute value
    )*
)
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;$1strong$3&gt;</pre>
<pre>&lt;\1strong\3&gt;</pre>
<pre>&lt;$1strong&gt;</pre>
<pre>&lt;\1strong&gt;</pre>
<h2>9.3. Remove All XML-Style Tags Except &lt;em&gt; and
    &lt;strong&gt;</h2>
<h3>Solution</h3>
<h4>Solution 1: Match tags except &lt;em&gt; and
        &lt;strong&gt;</h4>
<pre>&lt;/?(?!(?:em|strong)\b)[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt; /?                   # Permit closing tags
(?!
    (?: em | strong )  # List of tags to avoid matching
    \b                 # Word boundary avoids partial word matches
)
[a-z]                  # Tag name initial character must be a-z
(?: [^&gt;"']             # Any character except &gt;, ", or '
  | "[^"]*"            # Double-quoted attribute value
  | '[^']*'            # Single-quoted attribute value
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Solution 2: Match tags except &lt;em&gt; and &lt;strong&gt;,
        and any tags that contain attributes</h4>
<pre>&lt;/?(?!(?:em|strong)\s*&gt;)[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt; /?                   # Permit closing tags
(?!
    (?: em | strong )  # List of tags to avoid matching
    \s* &gt;              # Only avoid tags if they contain no attributes
)
[a-z]                  # Tag name initial character must be a-z
(?: [^&gt;"']             # Any character except &gt;, ", or '
  | "[^"]*"            # Double-quoted attribute value
  | '[^']*'            # Single-quoted attribute value
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Whitelist specific attributes</h4>
<pre>&lt;(?!(?:em|strong|a(?:\s+(?:href|title)\s*=\s*(?:"[^"]*"|'[^']*'))*)\s*&gt;)[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt; /?          # Permit closing tags
(?!
  (?: em      # Dont match &lt;em&gt;
    | strong  #   or &lt;strong&gt;
    | a       #   or &lt;a&gt;
      (?:     # Only avoid matching &lt;a&gt; tags that use only
        \s+   #   href and/or title attributes
        (?:href|title)
        \s*=\s*
        (?:"[^"]*"|'[^']*')  # Quoted attribute value
      )*
  )
  \s* &gt;       # Only avoid matching these tags when they're
)             #   limited to any attributes permitted above
[a-z]         # Tag name initial character must be a-z
(?: [^&gt;"']    # Any character except &gt;, ", or '
  | "[^"]*"   # Double-quoted attribute value
  | '[^']*'   # Single-quoted attribute value
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>9.4. Match XML Names</h2>
<h3>Solution</h3>
<h4>XML 1.0 names (approximate)</h4>
<pre>^[:_\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nl}][:_\-.\p{L}\p{M}\p{Nd}\p{Nl}]*$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<h4>XML 1.1 names (exact)</h4>
<pre>^[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:_\-.A-Za-z0-9\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u036F\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>^[:_A-Za-z\x{C0}-\x{D6}\x{D8}-\x{F6}\x{F8}-\x{2FF}\x{370}-\x{37D}\x{37F}-\x{1FFF}\x{200C}\x{200D}\x{2070}-\x{218F}\x{2C00}-\x{2FEF}\x{3001}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFFD}][:_\-.A-Za-z0-9\x{B7}\x{C0}-\x{D6}\x{D8}-\x{F6}\x{F8}-\x{36F}\x{370}-\x{37D}\x{37F}-\x{1FFF}\x{200C}\x{200D}\x{203F}\x{2040}\x{2070}-\x{218F}\x{2C00}-\x{2FEF}\x{3001}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFFD}]*$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<h3>Discussion</h3>
<h4>XML 1.0 names</h4>
<pre>^                                   # Start of string
[:_\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nl}]  # Initial name character
[:_\-.\p{L}\p{M}\p{Nd}\p{Nl}]*      # Subsequent name characters (optional)
$                                   # End of string</pre>
<p>Regex options: Free-spacing (“^ and $ match at line breaks” must not be
          set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<pre>^[:_\p{L&amp;}\p{Lo}\p{Nl}][:_\-.\pL\pM\p{Nd}\p{Nl}]*$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
Regex flavors: PCRE,
          Perl</p>
<pre>^[:_\p{L}\p{Nl}-[\p{Lm}]][:_\-.\p{L}\p{M}\p{Nd}\p{Nl}]*$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
</p><pre>^[:_\pL\p{Nl}&amp;&amp;[^\p{Lm}]][:_\-.\pL\pM\p{Nd}\p{Nl}]*$</pre>
<p>Regex options: None
          (“^ and $ match at line breaks” must not be set)<br>
</p><h3>Variations</h3>
<pre>[^\d\s"'/&lt;=&gt;][^\s"'/&lt;=&gt;]*</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?!\d)[^\s"'/&lt;=&gt;]+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.5. Convert Plain Text to HTML by Adding &lt;p&gt; and &lt;br&gt;
    Tags</h2>
<h3>Solution</h3>
<h4>Step 2: Replace all line breaks with &lt;br&gt;</h4>
<pre>\r\n?|\n</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\R</pre>
<p>Regex options: None<br>
Regex flavors: PCRE
          7, Perl 5.10</p>
<pre>&lt;br&gt;</pre>
<h4>Step 3: Replace double &lt;br&gt; tags with
        &lt;/p&gt;&lt;p&gt;</h4>
<pre>&lt;br&gt;\s*&lt;br&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/p&gt;&lt;p&gt;</pre>
<h4>Example JavaScript solution</h4>
<pre>function htmlFromPlainText(subject) {
    // Step 1 (plain text searches)
    subject = subject.replace(/&amp;/g, "&amp;amp;").
                      replace(/&lt;/g, "&amp;lt;").
                      replace(/&gt;/g, "&amp;gt;");

    // Step 2
    subject = subject.replace(/\r\n?|\n/g, "&lt;br&gt;");

    // Step 3
    subject = subject.replace(/&lt;br&gt;\s*&lt;br&gt;/g, "&lt;/p&gt;&lt;p&gt;");

    // Step 4
    subject = "&lt;p&gt;" + subject + "&lt;/p&gt;";

    return subject;
}

// Run some tests...
htmlFromPlainText("Test.");            // -&gt; "&lt;p&gt;Test.&lt;/p&gt;"
htmlFromPlainText("Test.\n");          // -&gt; "&lt;p&gt;Test.&lt;br&gt;&lt;/p&gt;"
htmlFromPlainText("Test.\n\n");        // -&gt; "&lt;p&gt;Test.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;"
htmlFromPlainText("Test1.\nTest2.");   // -&gt; "&lt;p&gt;Test1.&lt;br&gt;Test2.&lt;/p&gt;"
htmlFromPlainText("Test1.\n\nTest2."); // -&gt; "&lt;p&gt;Test1.&lt;/p&gt;&lt;p&gt;Test2.&lt;/p&gt;"
htmlFromPlainText("&lt; AT&amp;T &gt;");         // -&gt; "&lt;p&gt;&amp;lt; AT&amp;amp;T &amp;gt;&lt;/p&gt;"</pre>
<h2>9.6. Decode XML Entities</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>&amp;(?:#([0-9]+)|#x([0-9a-fA-F]+)|([0-9a-zA-Z]+));</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Example JavaScript solution</h4>
<pre>// Accepts the match ($0) and backreferences; returns replacement text
function callback($0, $1, $2, $3) {
    var charCode;

    // Name lookup object that maps to decimal character codes
    // Equivalent hexadecimal numbers are listed in comments
    var names = {
        quot: 34, // 0x22
        amp: 38, // 0x26
        apos: 39, // 0x27
        lt: 60, // 0x3C
        gt: 62 // 0x3E
    };

    // Decimal character reference
    if ($1) {
        charCode = parseInt($1, 10);
    // Hexadecimal character reference
    } else if ($2) {
        charCode = parseInt($2, 16);
    // Named entity with a lookup mapping
    } else if ($3 &amp;&amp; ($3 in names)) {
        charCode = names[$3];
    // Invalid or unknown entity name
    } else {
        return $0; // Return the match unaltered
    }

    // Return a literal character
    return String.fromCharCode(charCode);
}

// Replace all entities with literal text
subject = subject.replace(
        /&amp;(?:#([0-9]+)|#x([0-9a-fA-F]+)|([0-9a-zA-Z]+));/g,
        callback);</pre>
<h3>Discussion</h3>
<pre>"&amp;lt; &amp;bogus; dec &amp;#65;&amp;#0065; &amp;amp;lt; hex &amp;#x41;&amp;#x041; &amp;gt;"</pre>
<pre>"&lt; &amp;bogus; dec AA &amp;lt; hex AA &gt;"</pre>
<h2>9.7. Find a Specific Attribute in XML-Style Tags</h2>
<h3>Solution</h3>
<h4>Tags that contain an id attribute (quick and dirty)</h4>
<pre>&lt;[^&gt;]+\sid\b[^&gt;]*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;         # Start of the tag
[^&gt;]+     # Tag name, attributes, etc.
\s id \b  # The target attribute name, as a whole word
[^&gt;]*     # The remainder of the tag, including the id attribute's value
&gt;         # End of the tag</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Tags that contain an id attribute (more reliable)</h4>
<pre>&lt;(?:[^&gt;"']|"[^"]*"|'[^']*')+?\sid\s*=\s*("[^"]*"|'[^']*')(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?: [^&gt;"']             # Tag and attribute names, etc.
  | "[^"]*"            #   and quoted attribute values
  | '[^']*'
)+?
\s id                  # The target attribute name, as a whole word
\s* = \s*              # Attribute name-value delimiter
( "[^"]*" | '[^']*' )  # Capture the attribute value to backreference 1
(?: [^&gt;"']             # Any remaining characters
  | "[^"]*"            #   and quoted attribute values
  | '[^']*'
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>&lt;div&gt; tags that contain an id attribute</h4>
<pre>&lt;div\s(?:[^&gt;"']|"[^"]*"|'[^']*')*?\bid\s*=\s*("[^"]*"|'[^']*')(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;div \s                # Tag name and following whitespace character
(?: [^&gt;"']             # Tag and attribute names, etc.
  | "[^"]*"            #   and quoted attribute values
  | '[^']*'
)*?
\b id                  # The target attribute name, as a whole word
\s* = \s*              # Attribute name-value delimiter
( "[^"]*" | '[^']*' )  # Capture the attribute value to backreference 1
(?: [^&gt;"']             # Any remaining characters
  | "[^"]*"            #   and quoted attribute values
  | '[^']*'
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Tags that contain an id attribute with the value
        “my-id”</h4>
<pre>&lt;(?:[^&gt;"']|"[^"]*"|'[^']*')+?\sid\s*=\s*(?:"my-id"|'my-id')(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?: [^&gt;"']     # Tag and attribute names, etc.
  | "[^"]*"    #   and quoted attribute values
  | '[^']*'
)+?
\s id          # The target attribute name, as a whole word
\s* = \s*      # Attribute name-value delimiter
(?: "my-id"    # The target attribute value
  | 'my-id' )  #   surrounded by single or double quotes
(?: [^&gt;"']     # Any remaining characters
  | "[^"]*"    #   and quoted attribute values
  | '[^']*'
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Tags that contain “my-class” within their class attribute
        value</h4>
<pre>&lt;(?:[^&gt;"']|"[^"]*"|'[^']*')+&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:[^&gt;"']|"[^"]*"|'[^']*')+?\sclass\s*=\s*("[^"]*"|'[^']*')</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>["'\s]my-class["'\s]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?:^|\s)my-class(?:\s|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.8. Add a cellspacing Attribute to &lt;table&gt; Tags That Do Not
    Already Include It</h2>
<h3>Solution</h3>
<h4>Solution 1, simplistic</h4>
<pre>&lt;table\b(?![^&gt;]*?\scellspacing\b)([^&gt;]*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;table \b            # Match "&lt;table", as a complete word
(?!                  # Not followed by:
  [^&gt;]*?             #   Any attributes, etc.
  \s cellspacing \b  #   "cellspacing", as a complete word
)
([^&gt;]*)              # Capture attributes, etc. to backreference 1
&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Solution 2, more reliable</h4>
<pre>&lt;table\b(?!(?:[^&gt;"']|"[^"]*"|'[^']*')*?\scellspacing\b)((?:[^&gt;"']|"[^"]*"|'[^']*')*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;table \b  # Match "&lt;table", as a complete word
(?!  # Not followed by: Any attributes, etc., then "cellspacing"
  (?:[^&gt;"']|"[^"]*"|'[^']*')*?
  \s cellspacing \b
)
(  # Capture attributes, etc. to backreference 1
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
)
&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Insert the new attribute</h4>
<pre>&lt;table cellspacing="0"$1&gt;</pre>
<pre>&lt;table cellspacing="0"\1&gt;</pre>
<h2>9.9. Remove XML-Style Comments</h2>
<h3>Solution</h3>
<pre>&lt;!--.*?--&gt;</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--[\s\S]*?--&gt;</pre>
<p>Regex options: None<br>
</p><h3>Discussion</h3>
<h4>When comments can’t be removed</h4>
<pre>&lt;(script|style|textarea|title|xmp)\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;.*?&lt;/\1\s*&gt;|&lt;plaintext\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;.*|&lt;[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;|&lt;!\[CDATA\[.*?]]&gt;</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre># Special element: tag and its content
&lt;( script | style | textarea | title | xmp )\b
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt; .*? &lt;/\1\s*&gt;
|
# &lt;plaintext/&gt; continues until the end of the string
&lt;plaintext\b
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt; .*
|
# Standard element: tag only
&lt;[a-z]  # Tag name initial character
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt;
|
# CDATA section
&lt;!\[CDATA\[ .*? ]]&gt;</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;(script|style|textarea|title|xmp)\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;[\s\S]*?&lt;/\1\s*&gt;|&lt;plaintext\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;[\s\S]*|&lt;[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;|&lt;!\[CDATA\[[\s\S]*?]]&gt;</pre>
<p>Regex options: Case
          insensitive<br>
</p><h3>Variations</h3>
<h4>Find valid XML comments</h4>
<pre>&lt;!--[^-]*(?:-[^-]+)*--\s*&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--(?&gt;-?[^-]+)*--\s*&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby</p>
<h4>Find valid HTML comments</h4>
<pre>&lt;!--(?!-?&gt;)[^-]*(?:-[^-]+)*--&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.10. Find Words Within XML-Style Comments</h2>
<h3>Problem</h3>
<pre>        This "TODO" is not within a comment, but the next one is. &lt;!-- 
        TODO
        : Come up with a cooler comment for this example. --&gt;</pre>
<h3>Solution</h3>
<h4>Two-step approach</h4>
<pre>&lt;!--.*?--&gt;</pre>
<p>Regex options: Dot
          matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--[\s\S]*?--&gt;</pre>
<p>Regex options: None<br>
</p><pre>\bTODO\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Single-step approach</h4>
<pre>\bTODO\b(?=(?:(?!&lt;!--).)*?--&gt;)</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>\bTODO\b(?=(?:(?!&lt;!--)[\s\S])*?--&gt;)</pre>
<p>Regex options: Case
          insensitive<br>
</p><h3>Discussion</h3>
<h4>Single-step approach</h4>
<pre>\b TODO \b      # Match the characters "TODO", as a complete word
(?=             # Followed by:
  (?:           #   Group but don't capture:
    (?! &lt;!-- )  #     Not followed by: "&lt;!--"
    .           #     Match any single character
  )*?           #   Repeat zero or more times, as few as possible (lazy)
  --&gt;           #   Match the characters "--&gt;"
)</pre>
<p>Regex options: Dot
          matches line breaks, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?&lt;=&lt;!--(?:(?!--&gt;).)*?)\bTODO\b(?=(?:(?!&lt;!--).)*?--&gt;)</pre>
<p>Regex options: Case
        insensitive, dot matches line breaks<br>
</p><h2>9.11. Change the Delimiter Used in CSV Files</h2>
<h3>Solution</h3>
<pre>(,|\r?\n|^)([^",\r\n]+|"(?:[^"]|"")*")?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>( , | \r?\n | ^ )   # Capture the leading field delimiter to backref 1
(                   # Capture a single field to backref 2:
  [^",\r\n]+        #   Unquoted field
|                   #  Or:
  " (?:[^"]|"")* "  #   Quoted field (may contain escaped double quotes)
)?                  # The group is optional because fields may be empty</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Example web page with JavaScript</h4>
<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Change CSV delimiters from commas to tabs&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;Input:&lt;/p&gt;
&lt;textarea id="input" rows="5" cols="75"&gt;&lt;/textarea&gt;

&lt;p&gt;&lt;input type="button" value="Replace" onclick="commasToTabs()"&gt;&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;textarea id="output" rows="5" cols="75"&gt;&lt;/textarea&gt;

&lt;script&gt;
function commasToTabs() {
    var input  = document.getElementById("input"),
        output = document.getElementById("output"),
        regex  = /(,|\r?\n|^)([^",\r\n]+|"(?:[^"]|"")*")?/g,
        result = "",
        match;

    while (match = regex.exec(input.value)) {
        // Check the value of backreference 1
        if (match[1] == ",") {
            // Add a tab (in place of the matched comma) and backreference
            // 2 to the result. If backreference 2 is undefined (because
            // the optional, second capturing group did not participate in
            // the match), use an empty string instead.
            result += "\t" + (match[2] || "");
        } else {
            // Add the entire match to the result
            result += match[0];
        }

        // If there is an empty match, prevent some browsers from getting
        // stuck in an infinite loop
        if (match.index == regex.lastIndex) {
            regex.lastIndex++;
        }
    }

    output.value = result;
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h2>9.12. Extract CSV Fields from a Specific Column</h2>
<h3>Solution</h3>
<pre>(,|\r?\n|^)([^",\r\n]+|"(?:[^"]|"")*")?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>( , | \r?\n | ^ )   # Capture the leading field delimiter to backref 1
(                   # Capture a single field to backref 2:
  [^",\r\n]+        #   Unquoted field
|                   #  Or:
  " (?:[^"]|"")* "  #   Quoted field (may contain escaped double quotes)
)?                  # The group is optional because fields may be empty</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Example web page with JavaScript</h4>
<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Extract the third column from a CSV string&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;Input:&lt;/p&gt;
&lt;textarea id="input" rows="5" cols="75"&gt;&lt;/textarea&gt;

&lt;p&gt;&lt;input type="button" value="Extract Column 3"
    onclick="displayCsvColumn(2)"&gt;&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;textarea id="output" rows="5" cols="75"&gt;&lt;/textarea&gt;

&lt;script&gt;
function displayCsvColumn(index) {
    var input = document.getElementById("input"),
        output = document.getElementById("output"),
        columnFields = getCsvColumn(input.value, index);

    if (columnFields.length &gt; 0) {
        // Show each record on its own line, separated by a line feed (\n)
        output.value = columnFields.join("\n");
    } else {
        output.value = "[No data found to extract]";
    }
}

// Return an array of CSV fields at the provided, zero-based index
function getCsvColumn(csv, index) {
    var regex = /(,|\r?\n|^)([^",\r\n]+|"(?:[^"]|"")*")?/g,
        result = [],
        columnIndex = 0,
        match;

    while (match = regex.exec(csv)) {
        // Check the value of backreference 1. If it's a comma,
        // increment columnIndex. Otherwise, reset it to zero.
        if (match[1] == ",") {
            columnIndex++;
        } else {
            columnIndex = 0;
        }
        if (columnIndex == index) {
            // Add the field (backref 2) at the end of the result array
            result.push(match[2]);
        }

        // If there is an empty match, prevent some browsers from getting
        // stuck in an infinite loop
        if (match.index == regex.lastIndex) {
            regex.lastIndex++;
        }
    }

    return result;
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h3>Variations</h3>
<h4>Match a CSV record and capture the field in column 1 to
        backreference 1</h4>
<pre>^([^",\r\n]+|"(?:[^"]|"")*")?(?:,(?:[^",\r\n]+|"(?:[^"]|"")*")?)*</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Match a CSV record and capture the field in column 2 to
        backreference 1</h4>
<pre>^(?:[^",\r\n]+|"(?:[^"]|"")*")?,([^",\r\n]+|"(?:[^"]|"")*")?(?:,(?:[^",\r\n]+|"(?:[^"]|"")*")?)*</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Match a CSV record and capture the field in column 3 or higher
        to backreference 1</h4>
<pre>^(?:[^",\r\n]+|"(?:[^"]|"")*")?(?:,(?:[^",\r\n]+|"(?:[^"]|"")*")?){1},([^",\r\n]+|"(?:[^"]|"")*")?(?:,(?:[^",\r\n]+|"(?:[^"]|"")*")?)*</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement string</h4>
<pre>$1</pre>
<pre>\1</pre>
<h2>9.13. Match INI Section Headers</h2>
<h3>Solution</h3>
<pre>^\[[^\]\r\n]+]</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>^\[Section1]</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.14. Match INI Section Blocks</h2>
<h3>Solution</h3>
<pre>^\[[^\]\r\n]+](?:\r?\n(?:[^[\r\n].*)?)*</pre>
<p>Regex options: ^ and $
        match at line breaks (“dot matches line breaks” must not be
        set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^ \[ [^\]\r\n]+ ]  # Match a section header
(?:                # Followed by the rest of the section:
  \r?\n            #   Match a line break character sequence
  (?:              #   After each line starts, match:
    [^[\r\n]       #     Any character except "[" or a line break character
    .*             #     Match the rest of the line
  )?               #   The group is optional to allow matching empty lines
)*                 # Continue until the end of the section</pre>
<p>Regex options: ^ and $
        match at line breaks, free-spacing (“dot matches line breaks” must not
        be set)<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>[Section1]
Item1=Value1
Item2=[Value2]

; [SectionA]
; The SectionA header has been commented out

ItemA=ValueA ; ItemA is not commented out, and is part of Section1

[Section2]
Item3=Value3
Item4 = Value4</pre>
<h2>9.15. Match INI Name-Value Pairs</h2>
<h3>Solution</h3>
<pre>^([^=;\r\n]+)=([^;\r\n]*)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^               # Start of a line
( [^=;\r\n]+ )  # Capture the name to backreference 1
=               # Name-value delimiter
( [^;\r\n]* )   # Capture the value to backreference 2</pre>
<p>Regex options: ^ and $
        match at line breaks, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>

</body></html>